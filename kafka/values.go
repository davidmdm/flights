// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package kafka

type Values struct {
	// Broker corresponds to the JSON schema field "broker".
	Broker *ValuesBroker `json:"broker,omitempty" yaml:"broker,omitempty" mapstructure:"broker,omitempty"`

	// Default Kubernetes cluster domain
	ClusterDomain string `json:"clusterDomain,omitempty" yaml:"clusterDomain,omitempty" mapstructure:"clusterDomain,omitempty"`

	// Annotations to add to all deployed objects
	CommonAnnotations ValuesCommonAnnotations `json:"commonAnnotations,omitempty" yaml:"commonAnnotations,omitempty" mapstructure:"commonAnnotations,omitempty"`

	// Labels to add to all deployed objects
	CommonLabels ValuesCommonLabels `json:"commonLabels,omitempty" yaml:"commonLabels,omitempty" mapstructure:"commonLabels,omitempty"`

	// Configuration file for Kafka, rendered as a template. Auto-generated based on
	// chart values when not specified.
	Config string `json:"config,omitempty" yaml:"config,omitempty" mapstructure:"config,omitempty"`

	// Controller corresponds to the JSON schema field "controller".
	Controller *ValuesController `json:"controller,omitempty" yaml:"controller,omitempty" mapstructure:"controller,omitempty"`

	// DiagnosticMode corresponds to the JSON schema field "diagnosticMode".
	DiagnosticMode *ValuesDiagnosticMode `json:"diagnosticMode,omitempty" yaml:"diagnosticMode,omitempty" mapstructure:"diagnosticMode,omitempty"`

	// allows users more control on the DNS settings for a Pod. Required if
	// `dnsPolicy` is set to `None`
	DnsConfig ValuesDnsConfig `json:"dnsConfig,omitempty" yaml:"dnsConfig,omitempty" mapstructure:"dnsConfig,omitempty"`

	// Specifies the DNS policy for the zookeeper pods
	DnsPolicy string `json:"dnsPolicy,omitempty" yaml:"dnsPolicy,omitempty" mapstructure:"dnsPolicy,omitempty"`

	// ConfigMap with Kafka Configuration
	ExistingConfigmap string `json:"existingConfigmap,omitempty" yaml:"existingConfigmap,omitempty" mapstructure:"existingConfigmap,omitempty"`

	// The name of an existing ConfigMap containing a log4j.properties file
	ExistingLog4JConfigMap string `json:"existingLog4jConfigMap,omitempty" yaml:"existingLog4jConfigMap,omitempty" mapstructure:"existingLog4jConfigMap,omitempty"`

	// Secret with additonal configuration that will be appended to the end of the
	// generated Kafka configuration file
	ExistingSecretConfig string `json:"existingSecretConfig,omitempty" yaml:"existingSecretConfig,omitempty" mapstructure:"existingSecretConfig,omitempty"`

	// ExternalAccess corresponds to the JSON schema field "externalAccess".
	ExternalAccess *ValuesExternalAccess `json:"externalAccess,omitempty" yaml:"externalAccess,omitempty" mapstructure:"externalAccess,omitempty"`

	// ExternalZookeeper corresponds to the JSON schema field "externalZookeeper".
	ExternalZookeeper *ValuesExternalZookeeper `json:"externalZookeeper,omitempty" yaml:"externalZookeeper,omitempty" mapstructure:"externalZookeeper,omitempty"`

	// Additional configuration to be appended at the end of the generated Kafka
	// configuration file.
	ExtraConfig string `json:"extraConfig,omitempty" yaml:"extraConfig,omitempty" mapstructure:"extraConfig,omitempty"`

	// Array of extra objects to deploy with the release
	ExtraDeploy []interface{} `json:"extraDeploy,omitempty" yaml:"extraDeploy,omitempty" mapstructure:"extraDeploy,omitempty"`

	// Extra environment variables to add to Kafka pods
	ExtraEnvVars []interface{} `json:"extraEnvVars,omitempty" yaml:"extraEnvVars,omitempty" mapstructure:"extraEnvVars,omitempty"`

	// ConfigMap with extra environment variables
	ExtraEnvVarsCM string `json:"extraEnvVarsCM,omitempty" yaml:"extraEnvVarsCM,omitempty" mapstructure:"extraEnvVarsCM,omitempty"`

	// Secret with extra environment variables
	ExtraEnvVarsSecret string `json:"extraEnvVarsSecret,omitempty" yaml:"extraEnvVarsSecret,omitempty" mapstructure:"extraEnvVarsSecret,omitempty"`

	// Additional content for the kafka init script, rendered as a template.
	ExtraInit string `json:"extraInit,omitempty" yaml:"extraInit,omitempty" mapstructure:"extraInit,omitempty"`

	// Optionally specify extra list of additional volumeMounts for the Kafka
	// container(s)
	ExtraVolumeMounts []interface{} `json:"extraVolumeMounts,omitempty" yaml:"extraVolumeMounts,omitempty" mapstructure:"extraVolumeMounts,omitempty"`

	// Optionally specify extra list of additional volumes for the Kafka pod(s)
	ExtraVolumes []interface{} `json:"extraVolumes,omitempty" yaml:"extraVolumes,omitempty" mapstructure:"extraVolumes,omitempty"`

	// String to fully override common.names.fullname
	FullnameOverride string `json:"fullnameOverride,omitempty" yaml:"fullnameOverride,omitempty" mapstructure:"fullnameOverride,omitempty"`

	// Global corresponds to the JSON schema field "global".
	Global *ValuesGlobal `json:"global,omitempty" yaml:"global,omitempty" mapstructure:"global,omitempty"`

	// Kafka Java Heap size
	HeapOpts string `json:"heapOpts,omitempty" yaml:"heapOpts,omitempty" mapstructure:"heapOpts,omitempty"`

	// Image corresponds to the JSON schema field "image".
	Image *ValuesImage `json:"image,omitempty" yaml:"image,omitempty" mapstructure:"image,omitempty"`

	// Add additional Add init containers to the Kafka pod(s)
	InitContainers []interface{} `json:"initContainers,omitempty" yaml:"initContainers,omitempty" mapstructure:"initContainers,omitempty"`

	// Override the setting 'inter.broker.protocol.version' during the ZK migration.
	InterBrokerProtocolVersion string `json:"interBrokerProtocolVersion,omitempty" yaml:"interBrokerProtocolVersion,omitempty" mapstructure:"interBrokerProtocolVersion,omitempty"`

	// Kraft corresponds to the JSON schema field "kraft".
	Kraft *ValuesKraft `json:"kraft,omitempty" yaml:"kraft,omitempty" mapstructure:"kraft,omitempty"`

	// Override Kubernetes version
	KubeVersion string `json:"kubeVersion,omitempty" yaml:"kubeVersion,omitempty" mapstructure:"kubeVersion,omitempty"`

	// Listeners corresponds to the JSON schema field "listeners".
	Listeners *ValuesListeners `json:"listeners,omitempty" yaml:"listeners,omitempty" mapstructure:"listeners,omitempty"`

	// An optional log4j.properties file to overwrite the default of the Kafka brokers
	Log4J string `json:"log4j,omitempty" yaml:"log4j,omitempty" mapstructure:"log4j,omitempty"`

	// Metrics corresponds to the JSON schema field "metrics".
	Metrics *ValuesMetrics `json:"metrics,omitempty" yaml:"metrics,omitempty" mapstructure:"metrics,omitempty"`

	// String to partially override common.names.fullname
	NameOverride string `json:"nameOverride,omitempty" yaml:"nameOverride,omitempty" mapstructure:"nameOverride,omitempty"`

	// NetworkPolicy corresponds to the JSON schema field "networkPolicy".
	NetworkPolicy *ValuesNetworkPolicy `json:"networkPolicy,omitempty" yaml:"networkPolicy,omitempty" mapstructure:"networkPolicy,omitempty"`

	// Provisioning corresponds to the JSON schema field "provisioning".
	Provisioning *ValuesProvisioning `json:"provisioning,omitempty" yaml:"provisioning,omitempty" mapstructure:"provisioning,omitempty"`

	// Rbac corresponds to the JSON schema field "rbac".
	Rbac *ValuesRbac `json:"rbac,omitempty" yaml:"rbac,omitempty" mapstructure:"rbac,omitempty"`

	// Sasl corresponds to the JSON schema field "sasl".
	Sasl *ValuesSasl `json:"sasl,omitempty" yaml:"sasl,omitempty" mapstructure:"sasl,omitempty"`

	// Additional configuration to be appended at the end of the generated Kafka
	// configuration file.
	SecretConfig string `json:"secretConfig,omitempty" yaml:"secretConfig,omitempty" mapstructure:"secretConfig,omitempty"`

	// Service corresponds to the JSON schema field "service".
	Service *ValuesService `json:"service,omitempty" yaml:"service,omitempty" mapstructure:"service,omitempty"`

	// ServiceAccount corresponds to the JSON schema field "serviceAccount".
	ServiceAccount *ValuesServiceAccount `json:"serviceAccount,omitempty" yaml:"serviceAccount,omitempty" mapstructure:"serviceAccount,omitempty"`

	// ServiceBindings corresponds to the JSON schema field "serviceBindings".
	ServiceBindings *ValuesServiceBindings `json:"serviceBindings,omitempty" yaml:"serviceBindings,omitempty" mapstructure:"serviceBindings,omitempty"`

	// Add additional sidecar containers to the Kafka pod(s)
	Sidecars []interface{} `json:"sidecars,omitempty" yaml:"sidecars,omitempty" mapstructure:"sidecars,omitempty"`

	// Tls corresponds to the JSON schema field "tls".
	Tls *ValuesTls `json:"tls,omitempty" yaml:"tls,omitempty" mapstructure:"tls,omitempty"`

	// VolumePermissions corresponds to the JSON schema field "volumePermissions".
	VolumePermissions *ValuesVolumePermissions `json:"volumePermissions,omitempty" yaml:"volumePermissions,omitempty" mapstructure:"volumePermissions,omitempty"`

	// Zookeeper corresponds to the JSON schema field "zookeeper".
	Zookeeper *ValuesZookeeper `json:"zookeeper,omitempty" yaml:"zookeeper,omitempty" mapstructure:"zookeeper,omitempty"`

	// Path which puts data under some path in the global ZooKeeper namespace
	ZookeeperChrootPath string `json:"zookeeperChrootPath,omitempty" yaml:"zookeeperChrootPath,omitempty" mapstructure:"zookeeperChrootPath,omitempty"`
}

type ValuesBroker struct {
	// Affinity for pod assignment
	Affinity ValuesBrokerAffinity `json:"affinity,omitempty" yaml:"affinity,omitempty" mapstructure:"affinity,omitempty"`

	// Override Kafka container arguments
	Args []interface{} `json:"args,omitempty" yaml:"args,omitempty" mapstructure:"args,omitempty"`

	// Mount Service Account token in pod
	AutomountServiceAccountToken bool `json:"automountServiceAccountToken,omitempty" yaml:"automountServiceAccountToken,omitempty" mapstructure:"automountServiceAccountToken,omitempty"`

	// Override Kafka container command
	Command []interface{} `json:"command,omitempty" yaml:"command,omitempty" mapstructure:"command,omitempty"`

	// Configuration file for Kafka broker-only nodes, rendered as a template.
	// Auto-generated based on chart values when not specified.
	Config string `json:"config,omitempty" yaml:"config,omitempty" mapstructure:"config,omitempty"`

	// ContainerSecurityContext corresponds to the JSON schema field
	// "containerSecurityContext".
	ContainerSecurityContext *ValuesBrokerContainerSecurityContext `json:"containerSecurityContext,omitempty" yaml:"containerSecurityContext,omitempty" mapstructure:"containerSecurityContext,omitempty"`

	// Custom livenessProbe that overrides the default one
	CustomLivenessProbe ValuesBrokerCustomLivenessProbe `json:"customLivenessProbe,omitempty" yaml:"customLivenessProbe,omitempty" mapstructure:"customLivenessProbe,omitempty"`

	// Custom readinessProbe that overrides the default one
	CustomReadinessProbe ValuesBrokerCustomReadinessProbe `json:"customReadinessProbe,omitempty" yaml:"customReadinessProbe,omitempty" mapstructure:"customReadinessProbe,omitempty"`

	// Custom startupProbe that overrides the default one
	CustomStartupProbe ValuesBrokerCustomStartupProbe `json:"customStartupProbe,omitempty" yaml:"customStartupProbe,omitempty" mapstructure:"customStartupProbe,omitempty"`

	// Whether information about services should be injected into pod's environment
	// variable
	EnableServiceLinks bool `json:"enableServiceLinks,omitempty" yaml:"enableServiceLinks,omitempty" mapstructure:"enableServiceLinks,omitempty"`

	// ConfigMap with Kafka Configuration for broker-only nodes.
	ExistingConfigmap string `json:"existingConfigmap,omitempty" yaml:"existingConfigmap,omitempty" mapstructure:"existingConfigmap,omitempty"`

	// Secret with additonal configuration that will be appended to the end of the
	// generated Kafka broker-only nodes configuration file
	ExistingSecretConfig string `json:"existingSecretConfig,omitempty" yaml:"existingSecretConfig,omitempty" mapstructure:"existingSecretConfig,omitempty"`

	// Additional configuration to be appended at the end of the generated Kafka
	// broker-only nodes configuration file.
	ExtraConfig string `json:"extraConfig,omitempty" yaml:"extraConfig,omitempty" mapstructure:"extraConfig,omitempty"`

	// Kafka broker-only extra containerPorts.
	ExtraContainerPorts []interface{} `json:"extraContainerPorts,omitempty" yaml:"extraContainerPorts,omitempty" mapstructure:"extraContainerPorts,omitempty"`

	// Extra environment variables to add to Kafka pods
	ExtraEnvVars []interface{} `json:"extraEnvVars,omitempty" yaml:"extraEnvVars,omitempty" mapstructure:"extraEnvVars,omitempty"`

	// ConfigMap with extra environment variables
	ExtraEnvVarsCM string `json:"extraEnvVarsCM,omitempty" yaml:"extraEnvVarsCM,omitempty" mapstructure:"extraEnvVarsCM,omitempty"`

	// Secret with extra environment variables
	ExtraEnvVarsSecret string `json:"extraEnvVarsSecret,omitempty" yaml:"extraEnvVarsSecret,omitempty" mapstructure:"extraEnvVarsSecret,omitempty"`

	// Optionally specify extra list of additional volumeMounts for the Kafka
	// container(s)
	ExtraVolumeMounts []interface{} `json:"extraVolumeMounts,omitempty" yaml:"extraVolumeMounts,omitempty" mapstructure:"extraVolumeMounts,omitempty"`

	// Optionally specify extra list of additional volumes for the Kafka pod(s)
	ExtraVolumes []interface{} `json:"extraVolumes,omitempty" yaml:"extraVolumes,omitempty" mapstructure:"extraVolumes,omitempty"`

	// Kafka Java Heap size for broker-only nodes
	HeapOpts string `json:"heapOpts,omitempty" yaml:"heapOpts,omitempty" mapstructure:"heapOpts,omitempty"`

	// Kafka pods host aliases
	HostAliases []interface{} `json:"hostAliases,omitempty" yaml:"hostAliases,omitempty" mapstructure:"hostAliases,omitempty"`

	// Specify if host IPC should be enabled for Kafka pods
	HostIPC bool `json:"hostIPC,omitempty" yaml:"hostIPC,omitempty" mapstructure:"hostIPC,omitempty"`

	// Specify if host network should be enabled for Kafka pods
	HostNetwork bool `json:"hostNetwork,omitempty" yaml:"hostNetwork,omitempty" mapstructure:"hostNetwork,omitempty"`

	// InitContainerResources corresponds to the JSON schema field
	// "initContainerResources".
	InitContainerResources *ValuesBrokerInitContainerResources `json:"initContainerResources,omitempty" yaml:"initContainerResources,omitempty" mapstructure:"initContainerResources,omitempty"`

	// Add additional Add init containers to the Kafka pod(s)
	InitContainers []interface{} `json:"initContainers,omitempty" yaml:"initContainers,omitempty" mapstructure:"initContainers,omitempty"`

	// lifecycleHooks for the Kafka container to automate configuration before or
	// after startup
	LifecycleHooks ValuesBrokerLifecycleHooks `json:"lifecycleHooks,omitempty" yaml:"lifecycleHooks,omitempty" mapstructure:"lifecycleHooks,omitempty"`

	// LivenessProbe corresponds to the JSON schema field "livenessProbe".
	LivenessProbe *ValuesBrokerLivenessProbe `json:"livenessProbe,omitempty" yaml:"livenessProbe,omitempty" mapstructure:"livenessProbe,omitempty"`

	// LogPersistence corresponds to the JSON schema field "logPersistence".
	LogPersistence *ValuesBrokerLogPersistence `json:"logPersistence,omitempty" yaml:"logPersistence,omitempty" mapstructure:"logPersistence,omitempty"`

	// Minimal node.id values for broker-only nodes. Do not change after first
	// initialization.
	MinId float64 `json:"minId,omitempty" yaml:"minId,omitempty" mapstructure:"minId,omitempty"`

	// How many seconds a pod needs to be ready before killing the next, during update
	MinReadySeconds float64 `json:"minReadySeconds,omitempty" yaml:"minReadySeconds,omitempty" mapstructure:"minReadySeconds,omitempty"`

	// NodeAffinityPreset corresponds to the JSON schema field "nodeAffinityPreset".
	NodeAffinityPreset *ValuesBrokerNodeAffinityPreset `json:"nodeAffinityPreset,omitempty" yaml:"nodeAffinityPreset,omitempty" mapstructure:"nodeAffinityPreset,omitempty"`

	// Node labels for pod assignment
	NodeSelector ValuesBrokerNodeSelector `json:"nodeSelector,omitempty" yaml:"nodeSelector,omitempty" mapstructure:"nodeSelector,omitempty"`

	// Pdb corresponds to the JSON schema field "pdb".
	Pdb *ValuesBrokerPdb `json:"pdb,omitempty" yaml:"pdb,omitempty" mapstructure:"pdb,omitempty"`

	// Persistence corresponds to the JSON schema field "persistence".
	Persistence *ValuesBrokerPersistence `json:"persistence,omitempty" yaml:"persistence,omitempty" mapstructure:"persistence,omitempty"`

	// Pod affinity preset. Ignored if `affinity` is set. Allowed values: `soft` or
	// `hard`
	PodAffinityPreset string `json:"podAffinityPreset,omitempty" yaml:"podAffinityPreset,omitempty" mapstructure:"podAffinityPreset,omitempty"`

	// Extra annotations for Kafka pods
	PodAnnotations ValuesBrokerPodAnnotations `json:"podAnnotations,omitempty" yaml:"podAnnotations,omitempty" mapstructure:"podAnnotations,omitempty"`

	// Pod anti-affinity preset. Ignored if `affinity` is set. Allowed values: `soft`
	// or `hard`
	PodAntiAffinityPreset string `json:"podAntiAffinityPreset,omitempty" yaml:"podAntiAffinityPreset,omitempty" mapstructure:"podAntiAffinityPreset,omitempty"`

	// Extra labels for Kafka pods
	PodLabels ValuesBrokerPodLabels `json:"podLabels,omitempty" yaml:"podLabels,omitempty" mapstructure:"podLabels,omitempty"`

	// StatefulSet controller supports relax its ordering guarantees while preserving
	// its uniqueness and identity guarantees. There are two valid pod management
	// policies: OrderedReady and Parallel
	PodManagementPolicy string `json:"podManagementPolicy,omitempty" yaml:"podManagementPolicy,omitempty" mapstructure:"podManagementPolicy,omitempty"`

	// PodSecurityContext corresponds to the JSON schema field "podSecurityContext".
	PodSecurityContext *ValuesBrokerPodSecurityContext `json:"podSecurityContext,omitempty" yaml:"podSecurityContext,omitempty" mapstructure:"podSecurityContext,omitempty"`

	// Name of the existing priority class to be used by kafka pods
	PriorityClassName string `json:"priorityClassName,omitempty" yaml:"priorityClassName,omitempty" mapstructure:"priorityClassName,omitempty"`

	// ReadinessProbe corresponds to the JSON schema field "readinessProbe".
	ReadinessProbe *ValuesBrokerReadinessProbe `json:"readinessProbe,omitempty" yaml:"readinessProbe,omitempty" mapstructure:"readinessProbe,omitempty"`

	// Number of Kafka broker-only nodes
	ReplicaCount float64 `json:"replicaCount,omitempty" yaml:"replicaCount,omitempty" mapstructure:"replicaCount,omitempty"`

	// Set container requests and limits for different resources like CPU or memory
	// (essential for production workloads)
	Resources ValuesBrokerResources `json:"resources,omitempty" yaml:"resources,omitempty" mapstructure:"resources,omitempty"`

	// Set container resources according to one common preset (allowed values: none,
	// nano, small, medium, large, xlarge, 2xlarge). This is ignored if
	// broker.resources is set (broker.resources is recommended for production).
	ResourcesPreset string `json:"resourcesPreset,omitempty" yaml:"resourcesPreset,omitempty" mapstructure:"resourcesPreset,omitempty"`

	// Name of the runtime class to be used by pod(s)
	RuntimeClassName string `json:"runtimeClassName,omitempty" yaml:"runtimeClassName,omitempty" mapstructure:"runtimeClassName,omitempty"`

	// Name of the k8s scheduler (other than default)
	SchedulerName string `json:"schedulerName,omitempty" yaml:"schedulerName,omitempty" mapstructure:"schedulerName,omitempty"`

	// Additional configuration to be appended at the end of the generated Kafka
	// broker-only nodes configuration file.
	SecretConfig string `json:"secretConfig,omitempty" yaml:"secretConfig,omitempty" mapstructure:"secretConfig,omitempty"`

	// Add additional sidecar containers to the Kafka pod(s)
	Sidecars []interface{} `json:"sidecars,omitempty" yaml:"sidecars,omitempty" mapstructure:"sidecars,omitempty"`

	// StartupProbe corresponds to the JSON schema field "startupProbe".
	StartupProbe *ValuesBrokerStartupProbe `json:"startupProbe,omitempty" yaml:"startupProbe,omitempty" mapstructure:"startupProbe,omitempty"`

	// Seconds the pod needs to gracefully terminate
	TerminationGracePeriodSeconds string `json:"terminationGracePeriodSeconds,omitempty" yaml:"terminationGracePeriodSeconds,omitempty" mapstructure:"terminationGracePeriodSeconds,omitempty"`

	// Tolerations for pod assignment
	Tolerations []interface{} `json:"tolerations,omitempty" yaml:"tolerations,omitempty" mapstructure:"tolerations,omitempty"`

	// Topology Spread Constraints for pod assignment spread across your cluster among
	// failure-domains. Evaluated as a template
	TopologySpreadConstraints []interface{} `json:"topologySpreadConstraints,omitempty" yaml:"topologySpreadConstraints,omitempty" mapstructure:"topologySpreadConstraints,omitempty"`

	// UpdateStrategy corresponds to the JSON schema field "updateStrategy".
	UpdateStrategy *ValuesBrokerUpdateStrategy `json:"updateStrategy,omitempty" yaml:"updateStrategy,omitempty" mapstructure:"updateStrategy,omitempty"`

	// Set to true to deploy cluster controller quorum
	ZookeeperMigrationMode bool `json:"zookeeperMigrationMode,omitempty" yaml:"zookeeperMigrationMode,omitempty" mapstructure:"zookeeperMigrationMode,omitempty"`
}

// Affinity for pod assignment
type ValuesBrokerAffinity map[string]interface{}

type ValuesBrokerContainerSecurityContext struct {
	// Force the child process to be run as non-privileged
	AllowPrivilegeEscalation bool `json:"allowPrivilegeEscalation,omitempty" yaml:"allowPrivilegeEscalation,omitempty" mapstructure:"allowPrivilegeEscalation,omitempty"`

	// Capabilities corresponds to the JSON schema field "capabilities".
	Capabilities *ValuesBrokerContainerSecurityContextCapabilities `json:"capabilities,omitempty" yaml:"capabilities,omitempty" mapstructure:"capabilities,omitempty"`

	// Enable Kafka containers' Security Context
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Allows the pod to mount the RootFS as ReadOnly only
	ReadOnlyRootFilesystem bool `json:"readOnlyRootFilesystem,omitempty" yaml:"readOnlyRootFilesystem,omitempty" mapstructure:"readOnlyRootFilesystem,omitempty"`

	// Set Kafka containers' Security Context runAsNonRoot
	RunAsNonRoot bool `json:"runAsNonRoot,omitempty" yaml:"runAsNonRoot,omitempty" mapstructure:"runAsNonRoot,omitempty"`

	// Set Kafka containers' Security Context runAsUser
	RunAsUser float64 `json:"runAsUser,omitempty" yaml:"runAsUser,omitempty" mapstructure:"runAsUser,omitempty"`
}

type ValuesBrokerContainerSecurityContextCapabilities struct {
	// Set Kafka containers' server Security Context capabilities to be dropped
	Drop []string `json:"drop,omitempty" yaml:"drop,omitempty" mapstructure:"drop,omitempty"`
}

// Custom livenessProbe that overrides the default one
type ValuesBrokerCustomLivenessProbe map[string]interface{}

// Custom readinessProbe that overrides the default one
type ValuesBrokerCustomReadinessProbe map[string]interface{}

// Custom startupProbe that overrides the default one
type ValuesBrokerCustomStartupProbe map[string]interface{}

type ValuesBrokerInitContainerResources struct {
	// The resources limits for the container
	Limits ValuesBrokerInitContainerResourcesLimits `json:"limits,omitempty" yaml:"limits,omitempty" mapstructure:"limits,omitempty"`

	// The requested resources for the container
	Requests ValuesBrokerInitContainerResourcesRequests `json:"requests,omitempty" yaml:"requests,omitempty" mapstructure:"requests,omitempty"`
}

// The resources limits for the container
type ValuesBrokerInitContainerResourcesLimits map[string]interface{}

// The requested resources for the container
type ValuesBrokerInitContainerResourcesRequests map[string]interface{}

// lifecycleHooks for the Kafka container to automate configuration before or after
// startup
type ValuesBrokerLifecycleHooks map[string]interface{}

type ValuesBrokerLivenessProbe struct {
	// Enable livenessProbe on Kafka containers
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Failure threshold for livenessProbe
	FailureThreshold float64 `json:"failureThreshold,omitempty" yaml:"failureThreshold,omitempty" mapstructure:"failureThreshold,omitempty"`

	// Initial delay seconds for livenessProbe
	InitialDelaySeconds float64 `json:"initialDelaySeconds,omitempty" yaml:"initialDelaySeconds,omitempty" mapstructure:"initialDelaySeconds,omitempty"`

	// Period seconds for livenessProbe
	PeriodSeconds float64 `json:"periodSeconds,omitempty" yaml:"periodSeconds,omitempty" mapstructure:"periodSeconds,omitempty"`

	// Success threshold for livenessProbe
	SuccessThreshold float64 `json:"successThreshold,omitempty" yaml:"successThreshold,omitempty" mapstructure:"successThreshold,omitempty"`

	// Timeout seconds for livenessProbe
	TimeoutSeconds float64 `json:"timeoutSeconds,omitempty" yaml:"timeoutSeconds,omitempty" mapstructure:"timeoutSeconds,omitempty"`
}

type ValuesBrokerLogPersistence struct {
	// Persistent Volume Access Modes
	AccessModes []string `json:"accessModes,omitempty" yaml:"accessModes,omitempty" mapstructure:"accessModes,omitempty"`

	// Annotations for the PVC
	Annotations ValuesBrokerLogPersistenceAnnotations `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Enable Kafka logs persistence using PVC, note that ZooKeeper persistence is
	// unaffected
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// A manually managed Persistent Volume and Claim
	ExistingClaim string `json:"existingClaim,omitempty" yaml:"existingClaim,omitempty" mapstructure:"existingClaim,omitempty"`

	// Mount path of the Kafka logs volume
	MountPath string `json:"mountPath,omitempty" yaml:"mountPath,omitempty" mapstructure:"mountPath,omitempty"`

	// Selector to match an existing Persistent Volume for Kafka log data PVC. If set,
	// the PVC can't have a PV dynamically provisioned for it
	Selector ValuesBrokerLogPersistenceSelector `json:"selector,omitempty" yaml:"selector,omitempty" mapstructure:"selector,omitempty"`

	// PVC Storage Request for Kafka logs volume
	Size string `json:"size,omitempty" yaml:"size,omitempty" mapstructure:"size,omitempty"`

	// PVC Storage Class for Kafka logs volume
	StorageClass string `json:"storageClass,omitempty" yaml:"storageClass,omitempty" mapstructure:"storageClass,omitempty"`
}

// Annotations for the PVC
type ValuesBrokerLogPersistenceAnnotations map[string]interface{}

// Selector to match an existing Persistent Volume for Kafka log data PVC. If set,
// the PVC can't have a PV dynamically provisioned for it
type ValuesBrokerLogPersistenceSelector map[string]interface{}

type ValuesBrokerNodeAffinityPreset struct {
	// Node label key to match Ignored if `affinity` is set.
	Key string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Node affinity preset type. Ignored if `affinity` is set. Allowed values: `soft`
	// or `hard`
	Type string `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`

	// Node label values to match. Ignored if `affinity` is set.
	Values []interface{} `json:"values,omitempty" yaml:"values,omitempty" mapstructure:"values,omitempty"`
}

// Node labels for pod assignment
type ValuesBrokerNodeSelector map[string]interface{}

type ValuesBrokerPdb struct {
	// Deploy a pdb object for the Kafka pod
	Create bool `json:"create,omitempty" yaml:"create,omitempty" mapstructure:"create,omitempty"`

	// Maximum number/percentage of unavailable Kafka replicas
	MaxUnavailable float64 `json:"maxUnavailable,omitempty" yaml:"maxUnavailable,omitempty" mapstructure:"maxUnavailable,omitempty"`

	// Maximum number/percentage of unavailable Kafka replicas
	MinAvailable string `json:"minAvailable,omitempty" yaml:"minAvailable,omitempty" mapstructure:"minAvailable,omitempty"`
}

type ValuesBrokerPersistence struct {
	// Persistent Volume Access Modes
	AccessModes []string `json:"accessModes,omitempty" yaml:"accessModes,omitempty" mapstructure:"accessModes,omitempty"`

	// Annotations for the PVC
	Annotations ValuesBrokerPersistenceAnnotations `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Enable Kafka data persistence using PVC, note that ZooKeeper persistence is
	// unaffected
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// A manually managed Persistent Volume and Claim
	ExistingClaim string `json:"existingClaim,omitempty" yaml:"existingClaim,omitempty" mapstructure:"existingClaim,omitempty"`

	// Labels for the PVC
	Labels ValuesBrokerPersistenceLabels `json:"labels,omitempty" yaml:"labels,omitempty" mapstructure:"labels,omitempty"`

	// Mount path of the Kafka data volume
	MountPath string `json:"mountPath,omitempty" yaml:"mountPath,omitempty" mapstructure:"mountPath,omitempty"`

	// Selector to match an existing Persistent Volume for Kafka data PVC. If set, the
	// PVC can't have a PV dynamically provisioned for it
	Selector ValuesBrokerPersistenceSelector `json:"selector,omitempty" yaml:"selector,omitempty" mapstructure:"selector,omitempty"`

	// PVC Storage Request for Kafka data volume
	Size string `json:"size,omitempty" yaml:"size,omitempty" mapstructure:"size,omitempty"`

	// PVC Storage Class for Kafka data volume
	StorageClass string `json:"storageClass,omitempty" yaml:"storageClass,omitempty" mapstructure:"storageClass,omitempty"`
}

// Annotations for the PVC
type ValuesBrokerPersistenceAnnotations map[string]interface{}

// Labels for the PVC
type ValuesBrokerPersistenceLabels map[string]interface{}

// Selector to match an existing Persistent Volume for Kafka data PVC. If set, the
// PVC can't have a PV dynamically provisioned for it
type ValuesBrokerPersistenceSelector map[string]interface{}

// Extra annotations for Kafka pods
type ValuesBrokerPodAnnotations map[string]interface{}

// Extra labels for Kafka pods
type ValuesBrokerPodLabels map[string]interface{}

type ValuesBrokerPodSecurityContext struct {
	// Enable security context for the pods
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Set Kafka pod's Security Context fsGroup
	FsGroup float64 `json:"fsGroup,omitempty" yaml:"fsGroup,omitempty" mapstructure:"fsGroup,omitempty"`

	// Set filesystem group change policy
	FsGroupChangePolicy string `json:"fsGroupChangePolicy,omitempty" yaml:"fsGroupChangePolicy,omitempty" mapstructure:"fsGroupChangePolicy,omitempty"`

	// SeccompProfile corresponds to the JSON schema field "seccompProfile".
	SeccompProfile *ValuesBrokerPodSecurityContextSeccompProfile `json:"seccompProfile,omitempty" yaml:"seccompProfile,omitempty" mapstructure:"seccompProfile,omitempty"`

	// Set filesystem extra groups
	SupplementalGroups []interface{} `json:"supplementalGroups,omitempty" yaml:"supplementalGroups,omitempty" mapstructure:"supplementalGroups,omitempty"`

	// Set kernel settings using the sysctl interface
	Sysctls []interface{} `json:"sysctls,omitempty" yaml:"sysctls,omitempty" mapstructure:"sysctls,omitempty"`
}

type ValuesBrokerPodSecurityContextSeccompProfile struct {
	// Set Kafka pod's Security Context seccomp profile
	Type string `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`
}

type ValuesBrokerReadinessProbe struct {
	// Enable readinessProbe on Kafka containers
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Failure threshold for readinessProbe
	FailureThreshold float64 `json:"failureThreshold,omitempty" yaml:"failureThreshold,omitempty" mapstructure:"failureThreshold,omitempty"`

	// Initial delay seconds for readinessProbe
	InitialDelaySeconds float64 `json:"initialDelaySeconds,omitempty" yaml:"initialDelaySeconds,omitempty" mapstructure:"initialDelaySeconds,omitempty"`

	// Period seconds for readinessProbe
	PeriodSeconds float64 `json:"periodSeconds,omitempty" yaml:"periodSeconds,omitempty" mapstructure:"periodSeconds,omitempty"`

	// Success threshold for readinessProbe
	SuccessThreshold float64 `json:"successThreshold,omitempty" yaml:"successThreshold,omitempty" mapstructure:"successThreshold,omitempty"`

	// Timeout seconds for readinessProbe
	TimeoutSeconds float64 `json:"timeoutSeconds,omitempty" yaml:"timeoutSeconds,omitempty" mapstructure:"timeoutSeconds,omitempty"`
}

// Set container requests and limits for different resources like CPU or memory
// (essential for production workloads)
type ValuesBrokerResources map[string]interface{}

type ValuesBrokerStartupProbe struct {
	// Enable startupProbe on Kafka containers
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Failure threshold for startupProbe
	FailureThreshold float64 `json:"failureThreshold,omitempty" yaml:"failureThreshold,omitempty" mapstructure:"failureThreshold,omitempty"`

	// Initial delay seconds for startupProbe
	InitialDelaySeconds float64 `json:"initialDelaySeconds,omitempty" yaml:"initialDelaySeconds,omitempty" mapstructure:"initialDelaySeconds,omitempty"`

	// Period seconds for startupProbe
	PeriodSeconds float64 `json:"periodSeconds,omitempty" yaml:"periodSeconds,omitempty" mapstructure:"periodSeconds,omitempty"`

	// Success threshold for startupProbe
	SuccessThreshold float64 `json:"successThreshold,omitempty" yaml:"successThreshold,omitempty" mapstructure:"successThreshold,omitempty"`

	// Timeout seconds for startupProbe
	TimeoutSeconds float64 `json:"timeoutSeconds,omitempty" yaml:"timeoutSeconds,omitempty" mapstructure:"timeoutSeconds,omitempty"`
}

type ValuesBrokerUpdateStrategy struct {
	// Kafka statefulset strategy type
	Type string `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`
}

// Annotations to add to all deployed objects
type ValuesCommonAnnotations map[string]interface{}

// Labels to add to all deployed objects
type ValuesCommonLabels map[string]interface{}

type ValuesController struct {
	// Affinity for pod assignment
	Affinity ValuesControllerAffinity `json:"affinity,omitempty" yaml:"affinity,omitempty" mapstructure:"affinity,omitempty"`

	// Override Kafka container arguments
	Args []interface{} `json:"args,omitempty" yaml:"args,omitempty" mapstructure:"args,omitempty"`

	// Mount Service Account token in pod
	AutomountServiceAccountToken bool `json:"automountServiceAccountToken,omitempty" yaml:"automountServiceAccountToken,omitempty" mapstructure:"automountServiceAccountToken,omitempty"`

	// Override Kafka container command
	Command []interface{} `json:"command,omitempty" yaml:"command,omitempty" mapstructure:"command,omitempty"`

	// Configuration file for Kafka controller-eligible nodes, rendered as a template.
	// Auto-generated based on chart values when not specified.
	Config string `json:"config,omitempty" yaml:"config,omitempty" mapstructure:"config,omitempty"`

	// ContainerSecurityContext corresponds to the JSON schema field
	// "containerSecurityContext".
	ContainerSecurityContext *ValuesControllerContainerSecurityContext `json:"containerSecurityContext,omitempty" yaml:"containerSecurityContext,omitempty" mapstructure:"containerSecurityContext,omitempty"`

	// If set to true, controller nodes will be deployed as dedicated controllers,
	// instead of controller+broker processes.
	ControllerOnly bool `json:"controllerOnly,omitempty" yaml:"controllerOnly,omitempty" mapstructure:"controllerOnly,omitempty"`

	// Custom livenessProbe that overrides the default one
	CustomLivenessProbe ValuesControllerCustomLivenessProbe `json:"customLivenessProbe,omitempty" yaml:"customLivenessProbe,omitempty" mapstructure:"customLivenessProbe,omitempty"`

	// Custom readinessProbe that overrides the default one
	CustomReadinessProbe ValuesControllerCustomReadinessProbe `json:"customReadinessProbe,omitempty" yaml:"customReadinessProbe,omitempty" mapstructure:"customReadinessProbe,omitempty"`

	// Custom startupProbe that overrides the default one
	CustomStartupProbe ValuesControllerCustomStartupProbe `json:"customStartupProbe,omitempty" yaml:"customStartupProbe,omitempty" mapstructure:"customStartupProbe,omitempty"`

	// Whether information about services should be injected into pod's environment
	// variable
	EnableServiceLinks bool `json:"enableServiceLinks,omitempty" yaml:"enableServiceLinks,omitempty" mapstructure:"enableServiceLinks,omitempty"`

	// ConfigMap with Kafka Configuration for controller-eligible nodes.
	ExistingConfigmap string `json:"existingConfigmap,omitempty" yaml:"existingConfigmap,omitempty" mapstructure:"existingConfigmap,omitempty"`

	// Secret with additonal configuration that will be appended to the end of the
	// generated Kafka controller-eligible nodes configuration file
	ExistingSecretConfig string `json:"existingSecretConfig,omitempty" yaml:"existingSecretConfig,omitempty" mapstructure:"existingSecretConfig,omitempty"`

	// Additional configuration to be appended at the end of the generated Kafka
	// controller-eligible nodes configuration file.
	ExtraConfig string `json:"extraConfig,omitempty" yaml:"extraConfig,omitempty" mapstructure:"extraConfig,omitempty"`

	// Kafka controller-eligible extra containerPorts.
	ExtraContainerPorts []interface{} `json:"extraContainerPorts,omitempty" yaml:"extraContainerPorts,omitempty" mapstructure:"extraContainerPorts,omitempty"`

	// Extra environment variables to add to Kafka pods
	ExtraEnvVars []interface{} `json:"extraEnvVars,omitempty" yaml:"extraEnvVars,omitempty" mapstructure:"extraEnvVars,omitempty"`

	// ConfigMap with extra environment variables
	ExtraEnvVarsCM string `json:"extraEnvVarsCM,omitempty" yaml:"extraEnvVarsCM,omitempty" mapstructure:"extraEnvVarsCM,omitempty"`

	// Secret with extra environment variables
	ExtraEnvVarsSecret string `json:"extraEnvVarsSecret,omitempty" yaml:"extraEnvVarsSecret,omitempty" mapstructure:"extraEnvVarsSecret,omitempty"`

	// Optionally specify extra list of additional volumeMounts for the Kafka
	// container(s)
	ExtraVolumeMounts []interface{} `json:"extraVolumeMounts,omitempty" yaml:"extraVolumeMounts,omitempty" mapstructure:"extraVolumeMounts,omitempty"`

	// Optionally specify extra list of additional volumes for the Kafka pod(s)
	ExtraVolumes []interface{} `json:"extraVolumes,omitempty" yaml:"extraVolumes,omitempty" mapstructure:"extraVolumes,omitempty"`

	// Kafka Java Heap size for controller-eligible nodes
	HeapOpts string `json:"heapOpts,omitempty" yaml:"heapOpts,omitempty" mapstructure:"heapOpts,omitempty"`

	// Kafka pods host aliases
	HostAliases []interface{} `json:"hostAliases,omitempty" yaml:"hostAliases,omitempty" mapstructure:"hostAliases,omitempty"`

	// Specify if host IPC should be enabled for Kafka pods
	HostIPC bool `json:"hostIPC,omitempty" yaml:"hostIPC,omitempty" mapstructure:"hostIPC,omitempty"`

	// Specify if host network should be enabled for Kafka pods
	HostNetwork bool `json:"hostNetwork,omitempty" yaml:"hostNetwork,omitempty" mapstructure:"hostNetwork,omitempty"`

	// InitContainerResources corresponds to the JSON schema field
	// "initContainerResources".
	InitContainerResources *ValuesControllerInitContainerResources `json:"initContainerResources,omitempty" yaml:"initContainerResources,omitempty" mapstructure:"initContainerResources,omitempty"`

	// Add additional Add init containers to the Kafka pod(s)
	InitContainers []interface{} `json:"initContainers,omitempty" yaml:"initContainers,omitempty" mapstructure:"initContainers,omitempty"`

	// lifecycleHooks for the Kafka container to automate configuration before or
	// after startup
	LifecycleHooks ValuesControllerLifecycleHooks `json:"lifecycleHooks,omitempty" yaml:"lifecycleHooks,omitempty" mapstructure:"lifecycleHooks,omitempty"`

	// LivenessProbe corresponds to the JSON schema field "livenessProbe".
	LivenessProbe *ValuesControllerLivenessProbe `json:"livenessProbe,omitempty" yaml:"livenessProbe,omitempty" mapstructure:"livenessProbe,omitempty"`

	// LogPersistence corresponds to the JSON schema field "logPersistence".
	LogPersistence *ValuesControllerLogPersistence `json:"logPersistence,omitempty" yaml:"logPersistence,omitempty" mapstructure:"logPersistence,omitempty"`

	// Minimal node.id values for controller-eligible nodes. Do not change after first
	// initialization.
	MinId float64 `json:"minId,omitempty" yaml:"minId,omitempty" mapstructure:"minId,omitempty"`

	// How many seconds a pod needs to be ready before killing the next, during update
	MinReadySeconds float64 `json:"minReadySeconds,omitempty" yaml:"minReadySeconds,omitempty" mapstructure:"minReadySeconds,omitempty"`

	// NodeAffinityPreset corresponds to the JSON schema field "nodeAffinityPreset".
	NodeAffinityPreset *ValuesControllerNodeAffinityPreset `json:"nodeAffinityPreset,omitempty" yaml:"nodeAffinityPreset,omitempty" mapstructure:"nodeAffinityPreset,omitempty"`

	// Node labels for pod assignment
	NodeSelector ValuesControllerNodeSelector `json:"nodeSelector,omitempty" yaml:"nodeSelector,omitempty" mapstructure:"nodeSelector,omitempty"`

	// Pdb corresponds to the JSON schema field "pdb".
	Pdb *ValuesControllerPdb `json:"pdb,omitempty" yaml:"pdb,omitempty" mapstructure:"pdb,omitempty"`

	// Persistence corresponds to the JSON schema field "persistence".
	Persistence *ValuesControllerPersistence `json:"persistence,omitempty" yaml:"persistence,omitempty" mapstructure:"persistence,omitempty"`

	// Pod affinity preset. Ignored if `affinity` is set. Allowed values: `soft` or
	// `hard`
	PodAffinityPreset string `json:"podAffinityPreset,omitempty" yaml:"podAffinityPreset,omitempty" mapstructure:"podAffinityPreset,omitempty"`

	// Extra annotations for Kafka pods
	PodAnnotations ValuesControllerPodAnnotations `json:"podAnnotations,omitempty" yaml:"podAnnotations,omitempty" mapstructure:"podAnnotations,omitempty"`

	// Pod anti-affinity preset. Ignored if `affinity` is set. Allowed values: `soft`
	// or `hard`
	PodAntiAffinityPreset string `json:"podAntiAffinityPreset,omitempty" yaml:"podAntiAffinityPreset,omitempty" mapstructure:"podAntiAffinityPreset,omitempty"`

	// Extra labels for Kafka pods
	PodLabels ValuesControllerPodLabels `json:"podLabels,omitempty" yaml:"podLabels,omitempty" mapstructure:"podLabels,omitempty"`

	// StatefulSet controller supports relax its ordering guarantees while preserving
	// its uniqueness and identity guarantees. There are two valid pod management
	// policies: OrderedReady and Parallel
	PodManagementPolicy string `json:"podManagementPolicy,omitempty" yaml:"podManagementPolicy,omitempty" mapstructure:"podManagementPolicy,omitempty"`

	// PodSecurityContext corresponds to the JSON schema field "podSecurityContext".
	PodSecurityContext *ValuesControllerPodSecurityContext `json:"podSecurityContext,omitempty" yaml:"podSecurityContext,omitempty" mapstructure:"podSecurityContext,omitempty"`

	// Name of the existing priority class to be used by kafka pods
	PriorityClassName string `json:"priorityClassName,omitempty" yaml:"priorityClassName,omitempty" mapstructure:"priorityClassName,omitempty"`

	// ReadinessProbe corresponds to the JSON schema field "readinessProbe".
	ReadinessProbe *ValuesControllerReadinessProbe `json:"readinessProbe,omitempty" yaml:"readinessProbe,omitempty" mapstructure:"readinessProbe,omitempty"`

	// Number of Kafka controller-eligible nodes
	ReplicaCount float64 `json:"replicaCount,omitempty" yaml:"replicaCount,omitempty" mapstructure:"replicaCount,omitempty"`

	// Set container requests and limits for different resources like CPU or memory
	// (essential for production workloads)
	Resources ValuesControllerResources `json:"resources,omitempty" yaml:"resources,omitempty" mapstructure:"resources,omitempty"`

	// Set container resources according to one common preset (allowed values: none,
	// nano, small, medium, large, xlarge, 2xlarge). This is ignored if
	// controller.resources is set (controller.resources is recommended for
	// production).
	ResourcesPreset string `json:"resourcesPreset,omitempty" yaml:"resourcesPreset,omitempty" mapstructure:"resourcesPreset,omitempty"`

	// Name of the runtime class to be used by pod(s)
	RuntimeClassName string `json:"runtimeClassName,omitempty" yaml:"runtimeClassName,omitempty" mapstructure:"runtimeClassName,omitempty"`

	// Name of the k8s scheduler (other than default)
	SchedulerName string `json:"schedulerName,omitempty" yaml:"schedulerName,omitempty" mapstructure:"schedulerName,omitempty"`

	// Additional configuration to be appended at the end of the generated Kafka
	// controller-eligible nodes configuration file.
	SecretConfig string `json:"secretConfig,omitempty" yaml:"secretConfig,omitempty" mapstructure:"secretConfig,omitempty"`

	// Add additional sidecar containers to the Kafka pod(s)
	Sidecars []interface{} `json:"sidecars,omitempty" yaml:"sidecars,omitempty" mapstructure:"sidecars,omitempty"`

	// StartupProbe corresponds to the JSON schema field "startupProbe".
	StartupProbe *ValuesControllerStartupProbe `json:"startupProbe,omitempty" yaml:"startupProbe,omitempty" mapstructure:"startupProbe,omitempty"`

	// Seconds the pod needs to gracefully terminate
	TerminationGracePeriodSeconds string `json:"terminationGracePeriodSeconds,omitempty" yaml:"terminationGracePeriodSeconds,omitempty" mapstructure:"terminationGracePeriodSeconds,omitempty"`

	// Tolerations for pod assignment
	Tolerations []interface{} `json:"tolerations,omitempty" yaml:"tolerations,omitempty" mapstructure:"tolerations,omitempty"`

	// Topology Spread Constraints for pod assignment spread across your cluster among
	// failure-domains. Evaluated as a template
	TopologySpreadConstraints []interface{} `json:"topologySpreadConstraints,omitempty" yaml:"topologySpreadConstraints,omitempty" mapstructure:"topologySpreadConstraints,omitempty"`

	// UpdateStrategy corresponds to the JSON schema field "updateStrategy".
	UpdateStrategy *ValuesControllerUpdateStrategy `json:"updateStrategy,omitempty" yaml:"updateStrategy,omitempty" mapstructure:"updateStrategy,omitempty"`

	// Set to true to deploy cluster controller quorum
	ZookeeperMigrationMode bool `json:"zookeeperMigrationMode,omitempty" yaml:"zookeeperMigrationMode,omitempty" mapstructure:"zookeeperMigrationMode,omitempty"`
}

// Affinity for pod assignment
type ValuesControllerAffinity map[string]interface{}

type ValuesControllerContainerSecurityContext struct {
	// Force the child process to be run as non-privileged
	AllowPrivilegeEscalation bool `json:"allowPrivilegeEscalation,omitempty" yaml:"allowPrivilegeEscalation,omitempty" mapstructure:"allowPrivilegeEscalation,omitempty"`

	// Capabilities corresponds to the JSON schema field "capabilities".
	Capabilities *ValuesControllerContainerSecurityContextCapabilities `json:"capabilities,omitempty" yaml:"capabilities,omitempty" mapstructure:"capabilities,omitempty"`

	// Enable Kafka containers' Security Context
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Allows the pod to mount the RootFS as ReadOnly only
	ReadOnlyRootFilesystem bool `json:"readOnlyRootFilesystem,omitempty" yaml:"readOnlyRootFilesystem,omitempty" mapstructure:"readOnlyRootFilesystem,omitempty"`

	// Set Kafka containers' Security Context runAsNonRoot
	RunAsNonRoot bool `json:"runAsNonRoot,omitempty" yaml:"runAsNonRoot,omitempty" mapstructure:"runAsNonRoot,omitempty"`

	// Set Kafka containers' Security Context runAsUser
	RunAsUser float64 `json:"runAsUser,omitempty" yaml:"runAsUser,omitempty" mapstructure:"runAsUser,omitempty"`
}

type ValuesControllerContainerSecurityContextCapabilities struct {
	// Set Kafka containers' server Security Context capabilities to be dropped
	Drop []string `json:"drop,omitempty" yaml:"drop,omitempty" mapstructure:"drop,omitempty"`
}

// Custom livenessProbe that overrides the default one
type ValuesControllerCustomLivenessProbe map[string]interface{}

// Custom readinessProbe that overrides the default one
type ValuesControllerCustomReadinessProbe map[string]interface{}

// Custom startupProbe that overrides the default one
type ValuesControllerCustomStartupProbe map[string]interface{}

type ValuesControllerInitContainerResources struct {
	// The resources limits for the init container
	Limits ValuesControllerInitContainerResourcesLimits `json:"limits,omitempty" yaml:"limits,omitempty" mapstructure:"limits,omitempty"`

	// The requested resources for the init container
	Requests ValuesControllerInitContainerResourcesRequests `json:"requests,omitempty" yaml:"requests,omitempty" mapstructure:"requests,omitempty"`
}

// The resources limits for the init container
type ValuesControllerInitContainerResourcesLimits map[string]interface{}

// The requested resources for the init container
type ValuesControllerInitContainerResourcesRequests map[string]interface{}

// lifecycleHooks for the Kafka container to automate configuration before or after
// startup
type ValuesControllerLifecycleHooks map[string]interface{}

type ValuesControllerLivenessProbe struct {
	// Enable livenessProbe on Kafka containers
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Failure threshold for livenessProbe
	FailureThreshold float64 `json:"failureThreshold,omitempty" yaml:"failureThreshold,omitempty" mapstructure:"failureThreshold,omitempty"`

	// Initial delay seconds for livenessProbe
	InitialDelaySeconds float64 `json:"initialDelaySeconds,omitempty" yaml:"initialDelaySeconds,omitempty" mapstructure:"initialDelaySeconds,omitempty"`

	// Period seconds for livenessProbe
	PeriodSeconds float64 `json:"periodSeconds,omitempty" yaml:"periodSeconds,omitempty" mapstructure:"periodSeconds,omitempty"`

	// Success threshold for livenessProbe
	SuccessThreshold float64 `json:"successThreshold,omitempty" yaml:"successThreshold,omitempty" mapstructure:"successThreshold,omitempty"`

	// Timeout seconds for livenessProbe
	TimeoutSeconds float64 `json:"timeoutSeconds,omitempty" yaml:"timeoutSeconds,omitempty" mapstructure:"timeoutSeconds,omitempty"`
}

type ValuesControllerLogPersistence struct {
	// Persistent Volume Access Modes
	AccessModes []string `json:"accessModes,omitempty" yaml:"accessModes,omitempty" mapstructure:"accessModes,omitempty"`

	// Annotations for the PVC
	Annotations ValuesControllerLogPersistenceAnnotations `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Enable Kafka logs persistence using PVC, note that ZooKeeper persistence is
	// unaffected
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// A manually managed Persistent Volume and Claim
	ExistingClaim string `json:"existingClaim,omitempty" yaml:"existingClaim,omitempty" mapstructure:"existingClaim,omitempty"`

	// Mount path of the Kafka logs volume
	MountPath string `json:"mountPath,omitempty" yaml:"mountPath,omitempty" mapstructure:"mountPath,omitempty"`

	// Selector to match an existing Persistent Volume for Kafka log data PVC. If set,
	// the PVC can't have a PV dynamically provisioned for it
	Selector ValuesControllerLogPersistenceSelector `json:"selector,omitempty" yaml:"selector,omitempty" mapstructure:"selector,omitempty"`

	// PVC Storage Request for Kafka logs volume
	Size string `json:"size,omitempty" yaml:"size,omitempty" mapstructure:"size,omitempty"`

	// PVC Storage Class for Kafka logs volume
	StorageClass string `json:"storageClass,omitempty" yaml:"storageClass,omitempty" mapstructure:"storageClass,omitempty"`
}

// Annotations for the PVC
type ValuesControllerLogPersistenceAnnotations map[string]interface{}

// Selector to match an existing Persistent Volume for Kafka log data PVC. If set,
// the PVC can't have a PV dynamically provisioned for it
type ValuesControllerLogPersistenceSelector map[string]interface{}

type ValuesControllerNodeAffinityPreset struct {
	// Node label key to match Ignored if `affinity` is set.
	Key string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Node affinity preset type. Ignored if `affinity` is set. Allowed values: `soft`
	// or `hard`
	Type string `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`

	// Node label values to match. Ignored if `affinity` is set.
	Values []interface{} `json:"values,omitempty" yaml:"values,omitempty" mapstructure:"values,omitempty"`
}

// Node labels for pod assignment
type ValuesControllerNodeSelector map[string]interface{}

type ValuesControllerPdb struct {
	// Deploy a pdb object for the Kafka pod
	Create bool `json:"create,omitempty" yaml:"create,omitempty" mapstructure:"create,omitempty"`

	// Maximum number/percentage of unavailable Kafka replicas
	MaxUnavailable float64 `json:"maxUnavailable,omitempty" yaml:"maxUnavailable,omitempty" mapstructure:"maxUnavailable,omitempty"`

	// Maximum number/percentage of unavailable Kafka replicas
	MinAvailable string `json:"minAvailable,omitempty" yaml:"minAvailable,omitempty" mapstructure:"minAvailable,omitempty"`
}

type ValuesControllerPersistence struct {
	// Persistent Volume Access Modes
	AccessModes []string `json:"accessModes,omitempty" yaml:"accessModes,omitempty" mapstructure:"accessModes,omitempty"`

	// Annotations for the PVC
	Annotations ValuesControllerPersistenceAnnotations `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Enable Kafka data persistence using PVC, note that ZooKeeper persistence is
	// unaffected
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// A manually managed Persistent Volume and Claim
	ExistingClaim string `json:"existingClaim,omitempty" yaml:"existingClaim,omitempty" mapstructure:"existingClaim,omitempty"`

	// Labels for the PVC
	Labels ValuesControllerPersistenceLabels `json:"labels,omitempty" yaml:"labels,omitempty" mapstructure:"labels,omitempty"`

	// Mount path of the Kafka data volume
	MountPath string `json:"mountPath,omitempty" yaml:"mountPath,omitempty" mapstructure:"mountPath,omitempty"`

	// Selector to match an existing Persistent Volume for Kafka data PVC. If set, the
	// PVC can't have a PV dynamically provisioned for it
	Selector ValuesControllerPersistenceSelector `json:"selector,omitempty" yaml:"selector,omitempty" mapstructure:"selector,omitempty"`

	// PVC Storage Request for Kafka data volume
	Size string `json:"size,omitempty" yaml:"size,omitempty" mapstructure:"size,omitempty"`

	// PVC Storage Class for Kafka data volume
	StorageClass string `json:"storageClass,omitempty" yaml:"storageClass,omitempty" mapstructure:"storageClass,omitempty"`
}

// Annotations for the PVC
type ValuesControllerPersistenceAnnotations map[string]interface{}

// Labels for the PVC
type ValuesControllerPersistenceLabels map[string]interface{}

// Selector to match an existing Persistent Volume for Kafka data PVC. If set, the
// PVC can't have a PV dynamically provisioned for it
type ValuesControllerPersistenceSelector map[string]interface{}

// Extra annotations for Kafka pods
type ValuesControllerPodAnnotations map[string]interface{}

// Extra labels for Kafka pods
type ValuesControllerPodLabels map[string]interface{}

type ValuesControllerPodSecurityContext struct {
	// Enable security context for the pods
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Set Kafka pod's Security Context fsGroup
	FsGroup float64 `json:"fsGroup,omitempty" yaml:"fsGroup,omitempty" mapstructure:"fsGroup,omitempty"`

	// Set filesystem group change policy
	FsGroupChangePolicy string `json:"fsGroupChangePolicy,omitempty" yaml:"fsGroupChangePolicy,omitempty" mapstructure:"fsGroupChangePolicy,omitempty"`

	// SeccompProfile corresponds to the JSON schema field "seccompProfile".
	SeccompProfile *ValuesControllerPodSecurityContextSeccompProfile `json:"seccompProfile,omitempty" yaml:"seccompProfile,omitempty" mapstructure:"seccompProfile,omitempty"`

	// Set filesystem extra groups
	SupplementalGroups []interface{} `json:"supplementalGroups,omitempty" yaml:"supplementalGroups,omitempty" mapstructure:"supplementalGroups,omitempty"`

	// Set kernel settings using the sysctl interface
	Sysctls []interface{} `json:"sysctls,omitempty" yaml:"sysctls,omitempty" mapstructure:"sysctls,omitempty"`
}

type ValuesControllerPodSecurityContextSeccompProfile struct {
	// Set Kafka pods's Security Context seccomp profile
	Type string `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`
}

type ValuesControllerReadinessProbe struct {
	// Enable readinessProbe on Kafka containers
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Failure threshold for readinessProbe
	FailureThreshold float64 `json:"failureThreshold,omitempty" yaml:"failureThreshold,omitempty" mapstructure:"failureThreshold,omitempty"`

	// Initial delay seconds for readinessProbe
	InitialDelaySeconds float64 `json:"initialDelaySeconds,omitempty" yaml:"initialDelaySeconds,omitempty" mapstructure:"initialDelaySeconds,omitempty"`

	// Period seconds for readinessProbe
	PeriodSeconds float64 `json:"periodSeconds,omitempty" yaml:"periodSeconds,omitempty" mapstructure:"periodSeconds,omitempty"`

	// Success threshold for readinessProbe
	SuccessThreshold float64 `json:"successThreshold,omitempty" yaml:"successThreshold,omitempty" mapstructure:"successThreshold,omitempty"`

	// Timeout seconds for readinessProbe
	TimeoutSeconds float64 `json:"timeoutSeconds,omitempty" yaml:"timeoutSeconds,omitempty" mapstructure:"timeoutSeconds,omitempty"`
}

// Set container requests and limits for different resources like CPU or memory
// (essential for production workloads)
type ValuesControllerResources map[string]interface{}

type ValuesControllerStartupProbe struct {
	// Enable startupProbe on Kafka containers
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Failure threshold for startupProbe
	FailureThreshold float64 `json:"failureThreshold,omitempty" yaml:"failureThreshold,omitempty" mapstructure:"failureThreshold,omitempty"`

	// Initial delay seconds for startupProbe
	InitialDelaySeconds float64 `json:"initialDelaySeconds,omitempty" yaml:"initialDelaySeconds,omitempty" mapstructure:"initialDelaySeconds,omitempty"`

	// Period seconds for startupProbe
	PeriodSeconds float64 `json:"periodSeconds,omitempty" yaml:"periodSeconds,omitempty" mapstructure:"periodSeconds,omitempty"`

	// Success threshold for startupProbe
	SuccessThreshold float64 `json:"successThreshold,omitempty" yaml:"successThreshold,omitempty" mapstructure:"successThreshold,omitempty"`

	// Timeout seconds for startupProbe
	TimeoutSeconds float64 `json:"timeoutSeconds,omitempty" yaml:"timeoutSeconds,omitempty" mapstructure:"timeoutSeconds,omitempty"`
}

type ValuesControllerUpdateStrategy struct {
	// Kafka statefulset strategy type
	Type string `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`
}

type ValuesDiagnosticMode struct {
	// Args to override all containers in the statefulset
	Args []string `json:"args,omitempty" yaml:"args,omitempty" mapstructure:"args,omitempty"`

	// Command to override all containers in the statefulset
	Command []string `json:"command,omitempty" yaml:"command,omitempty" mapstructure:"command,omitempty"`

	// Enable diagnostic mode (all probes will be disabled and the command will be
	// overridden)
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`
}

// allows users more control on the DNS settings for a Pod. Required if `dnsPolicy`
// is set to `None`
type ValuesDnsConfig map[string]interface{}

type ValuesExternalAccess struct {
	// AutoDiscovery corresponds to the JSON schema field "autoDiscovery".
	AutoDiscovery *ValuesExternalAccessAutoDiscovery `json:"autoDiscovery,omitempty" yaml:"autoDiscovery,omitempty" mapstructure:"autoDiscovery,omitempty"`

	// Broker corresponds to the JSON schema field "broker".
	Broker *ValuesExternalAccessBroker `json:"broker,omitempty" yaml:"broker,omitempty" mapstructure:"broker,omitempty"`

	// Controller corresponds to the JSON schema field "controller".
	Controller *ValuesExternalAccessController `json:"controller,omitempty" yaml:"controller,omitempty" mapstructure:"controller,omitempty"`

	// Enable Kubernetes external cluster access to Kafka brokers
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`
}

type ValuesExternalAccessAutoDiscovery struct {
	// ContainerSecurityContext corresponds to the JSON schema field
	// "containerSecurityContext".
	ContainerSecurityContext *ValuesExternalAccessAutoDiscoveryContainerSecurityContext `json:"containerSecurityContext,omitempty" yaml:"containerSecurityContext,omitempty" mapstructure:"containerSecurityContext,omitempty"`

	// Enable using an init container to auto-detect external IPs/ports by querying
	// the K8s API
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Image corresponds to the JSON schema field "image".
	Image *ValuesExternalAccessAutoDiscoveryImage `json:"image,omitempty" yaml:"image,omitempty" mapstructure:"image,omitempty"`

	// Set container requests and limits for different resources like CPU or memory
	// (essential for production workloads)
	Resources ValuesExternalAccessAutoDiscoveryResources `json:"resources,omitempty" yaml:"resources,omitempty" mapstructure:"resources,omitempty"`

	// Set container resources according to one common preset (allowed values: none,
	// nano, small, medium, large, xlarge, 2xlarge). This is ignored if
	// externalAccess.autoDiscovery.resources is set
	// (externalAccess.autoDiscovery.resources is recommended for production).
	ResourcesPreset string `json:"resourcesPreset,omitempty" yaml:"resourcesPreset,omitempty" mapstructure:"resourcesPreset,omitempty"`
}

type ValuesExternalAccessAutoDiscoveryContainerSecurityContext struct {
	// Set Kafka auto-discovery containers' Security Context allowPrivilegeEscalation
	AllowPrivilegeEscalation bool `json:"allowPrivilegeEscalation,omitempty" yaml:"allowPrivilegeEscalation,omitempty" mapstructure:"allowPrivilegeEscalation,omitempty"`

	// Capabilities corresponds to the JSON schema field "capabilities".
	Capabilities *ValuesExternalAccessAutoDiscoveryContainerSecurityContextCapabilities `json:"capabilities,omitempty" yaml:"capabilities,omitempty" mapstructure:"capabilities,omitempty"`

	// Enable Kafka auto-discovery containers' Security Context
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Set Kafka auto-discovery containers' Security Context readOnlyRootFilesystem
	ReadOnlyRootFilesystem bool `json:"readOnlyRootFilesystem,omitempty" yaml:"readOnlyRootFilesystem,omitempty" mapstructure:"readOnlyRootFilesystem,omitempty"`

	// Set Kafka auto-discovery containers' Security Context runAsNonRoot
	RunAsNonRoot bool `json:"runAsNonRoot,omitempty" yaml:"runAsNonRoot,omitempty" mapstructure:"runAsNonRoot,omitempty"`

	// Set Kafka auto-discovery containers' Security Context runAsUser
	RunAsUser float64 `json:"runAsUser,omitempty" yaml:"runAsUser,omitempty" mapstructure:"runAsUser,omitempty"`

	// SeccompProfile corresponds to the JSON schema field "seccompProfile".
	SeccompProfile *ValuesExternalAccessAutoDiscoveryContainerSecurityContextSeccompProfile `json:"seccompProfile,omitempty" yaml:"seccompProfile,omitempty" mapstructure:"seccompProfile,omitempty"`
}

type ValuesExternalAccessAutoDiscoveryContainerSecurityContextCapabilities struct {
	// Set Kafka auto-discovery containers' Security Context capabilities to be
	// dropped
	Drop []string `json:"drop,omitempty" yaml:"drop,omitempty" mapstructure:"drop,omitempty"`
}

type ValuesExternalAccessAutoDiscoveryContainerSecurityContextSeccompProfile struct {
	// Set Kafka auto-discovery seccomp profile type
	Type string `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`
}

type ValuesExternalAccessAutoDiscoveryImage struct {
	// Kubectl image digest in the way sha256:aa.... Please note this parameter, if
	// set, will override the tag
	Digest string `json:"digest,omitempty" yaml:"digest,omitempty" mapstructure:"digest,omitempty"`

	// Init container auto-discovery image pull policy
	PullPolicy string `json:"pullPolicy,omitempty" yaml:"pullPolicy,omitempty" mapstructure:"pullPolicy,omitempty"`

	// Init container auto-discovery image pull secrets
	PullSecrets []interface{} `json:"pullSecrets,omitempty" yaml:"pullSecrets,omitempty" mapstructure:"pullSecrets,omitempty"`

	// Init container auto-discovery image registry
	Registry string `json:"registry,omitempty" yaml:"registry,omitempty" mapstructure:"registry,omitempty"`

	// Init container auto-discovery image repository
	Repository string `json:"repository,omitempty" yaml:"repository,omitempty" mapstructure:"repository,omitempty"`
}

// Set container requests and limits for different resources like CPU or memory
// (essential for production workloads)
type ValuesExternalAccessAutoDiscoveryResources map[string]interface{}

type ValuesExternalAccessBroker struct {
	// Service corresponds to the JSON schema field "service".
	Service *ValuesExternalAccessBrokerService `json:"service,omitempty" yaml:"service,omitempty" mapstructure:"service,omitempty"`
}

type ValuesExternalAccessBrokerService struct {
	// Whether to allocate node ports when service type is LoadBalancer
	AllocateLoadBalancerNodePorts bool `json:"allocateLoadBalancerNodePorts,omitempty" yaml:"allocateLoadBalancerNodePorts,omitempty" mapstructure:"allocateLoadBalancerNodePorts,omitempty"`

	// Service annotations for external access
	Annotations ValuesExternalAccessBrokerServiceAnnotations `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Domain or external ip used to configure Kafka external listener when service
	// type is NodePort or ClusterIP
	Domain string `json:"domain,omitempty" yaml:"domain,omitempty" mapstructure:"domain,omitempty"`

	// Use distinct service host IPs to configure Kafka external listener when service
	// type is NodePort. Length must be the same as replicaCount
	ExternalIPs []interface{} `json:"externalIPs,omitempty" yaml:"externalIPs,omitempty" mapstructure:"externalIPs,omitempty"`

	// Extra ports to expose in the Kafka external service
	ExtraPorts []interface{} `json:"extraPorts,omitempty" yaml:"extraPorts,omitempty" mapstructure:"extraPorts,omitempty"`

	// Service labels for external access
	Labels ValuesExternalAccessBrokerServiceLabels `json:"labels,omitempty" yaml:"labels,omitempty" mapstructure:"labels,omitempty"`

	// Array of load balancer annotations for each Kafka broker. Length must be the
	// same as replicaCount
	LoadBalancerAnnotations []interface{} `json:"loadBalancerAnnotations,omitempty" yaml:"loadBalancerAnnotations,omitempty" mapstructure:"loadBalancerAnnotations,omitempty"`

	// Array of load balancer IPs for each Kafka broker. Length must be the same as
	// replicaCount
	LoadBalancerIPs []interface{} `json:"loadBalancerIPs,omitempty" yaml:"loadBalancerIPs,omitempty" mapstructure:"loadBalancerIPs,omitempty"`

	// Array of load balancer Names for each Kafka broker. Length must be the same as
	// replicaCount
	LoadBalancerNames []interface{} `json:"loadBalancerNames,omitempty" yaml:"loadBalancerNames,omitempty" mapstructure:"loadBalancerNames,omitempty"`

	// Address(es) that are allowed when service is LoadBalancer
	LoadBalancerSourceRanges []interface{} `json:"loadBalancerSourceRanges,omitempty" yaml:"loadBalancerSourceRanges,omitempty" mapstructure:"loadBalancerSourceRanges,omitempty"`

	// Array of node ports used for each Kafka broker. Length must be the same as
	// replicaCount
	NodePorts []interface{} `json:"nodePorts,omitempty" yaml:"nodePorts,omitempty" mapstructure:"nodePorts,omitempty"`

	// Ports corresponds to the JSON schema field "ports".
	Ports *ValuesExternalAccessBrokerServicePorts `json:"ports,omitempty" yaml:"ports,omitempty" mapstructure:"ports,omitempty"`

	// Indicates that any agent which deals with endpoints for this Service should
	// disregard any indications of ready/not-ready
	PublishNotReadyAddresses bool `json:"publishNotReadyAddresses,omitempty" yaml:"publishNotReadyAddresses,omitempty" mapstructure:"publishNotReadyAddresses,omitempty"`

	// Kubernetes Service type for external access. It can be NodePort, LoadBalancer
	// or ClusterIP
	Type string `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`

	// Use service host IPs to configure Kafka external listener when service type is
	// NodePort
	UseHostIPs bool `json:"useHostIPs,omitempty" yaml:"useHostIPs,omitempty" mapstructure:"useHostIPs,omitempty"`

	// using the MY_POD_IP address for external access.
	UsePodIPs bool `json:"usePodIPs,omitempty" yaml:"usePodIPs,omitempty" mapstructure:"usePodIPs,omitempty"`
}

// Service annotations for external access
type ValuesExternalAccessBrokerServiceAnnotations map[string]interface{}

// Service labels for external access
type ValuesExternalAccessBrokerServiceLabels map[string]interface{}

type ValuesExternalAccessBrokerServicePorts struct {
	// Kafka port used for external access when service type is LoadBalancer
	External float64 `json:"external,omitempty" yaml:"external,omitempty" mapstructure:"external,omitempty"`
}

type ValuesExternalAccessController struct {
	// If set to true, force exposing controller-eligible nodes although they are
	// configured as controller-only nodes
	ForceExpose bool `json:"forceExpose,omitempty" yaml:"forceExpose,omitempty" mapstructure:"forceExpose,omitempty"`

	// Service corresponds to the JSON schema field "service".
	Service *ValuesExternalAccessControllerService `json:"service,omitempty" yaml:"service,omitempty" mapstructure:"service,omitempty"`
}

type ValuesExternalAccessControllerService struct {
	// Whether to allocate node ports when service type is LoadBalancer
	AllocateLoadBalancerNodePorts bool `json:"allocateLoadBalancerNodePorts,omitempty" yaml:"allocateLoadBalancerNodePorts,omitempty" mapstructure:"allocateLoadBalancerNodePorts,omitempty"`

	// Service annotations for external access
	Annotations ValuesExternalAccessControllerServiceAnnotations `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Domain or external ip used to configure Kafka external listener when service
	// type is NodePort or ClusterIP
	Domain string `json:"domain,omitempty" yaml:"domain,omitempty" mapstructure:"domain,omitempty"`

	// Use distinct service host IPs to configure Kafka external listener when service
	// type is NodePort. Length must be the same as replicaCount
	ExternalIPs []interface{} `json:"externalIPs,omitempty" yaml:"externalIPs,omitempty" mapstructure:"externalIPs,omitempty"`

	// Extra ports to expose in the Kafka external service
	ExtraPorts []interface{} `json:"extraPorts,omitempty" yaml:"extraPorts,omitempty" mapstructure:"extraPorts,omitempty"`

	// Service labels for external access
	Labels ValuesExternalAccessControllerServiceLabels `json:"labels,omitempty" yaml:"labels,omitempty" mapstructure:"labels,omitempty"`

	// Array of load balancer annotations for each Kafka broker. Length must be the
	// same as replicaCount
	LoadBalancerAnnotations []interface{} `json:"loadBalancerAnnotations,omitempty" yaml:"loadBalancerAnnotations,omitempty" mapstructure:"loadBalancerAnnotations,omitempty"`

	// Array of load balancer IPs for each Kafka broker. Length must be the same as
	// replicaCount
	LoadBalancerIPs []interface{} `json:"loadBalancerIPs,omitempty" yaml:"loadBalancerIPs,omitempty" mapstructure:"loadBalancerIPs,omitempty"`

	// Array of load balancer Names for each Kafka broker. Length must be the same as
	// replicaCount
	LoadBalancerNames []interface{} `json:"loadBalancerNames,omitempty" yaml:"loadBalancerNames,omitempty" mapstructure:"loadBalancerNames,omitempty"`

	// Address(es) that are allowed when service is LoadBalancer
	LoadBalancerSourceRanges []interface{} `json:"loadBalancerSourceRanges,omitempty" yaml:"loadBalancerSourceRanges,omitempty" mapstructure:"loadBalancerSourceRanges,omitempty"`

	// Array of node ports used for each Kafka broker. Length must be the same as
	// replicaCount
	NodePorts []interface{} `json:"nodePorts,omitempty" yaml:"nodePorts,omitempty" mapstructure:"nodePorts,omitempty"`

	// Ports corresponds to the JSON schema field "ports".
	Ports *ValuesExternalAccessControllerServicePorts `json:"ports,omitempty" yaml:"ports,omitempty" mapstructure:"ports,omitempty"`

	// Indicates that any agent which deals with endpoints for this Service should
	// disregard any indications of ready/not-ready
	PublishNotReadyAddresses bool `json:"publishNotReadyAddresses,omitempty" yaml:"publishNotReadyAddresses,omitempty" mapstructure:"publishNotReadyAddresses,omitempty"`

	// Kubernetes Service type for external access. It can be NodePort, LoadBalancer
	// or ClusterIP
	Type string `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`

	// Use service host IPs to configure Kafka external listener when service type is
	// NodePort
	UseHostIPs bool `json:"useHostIPs,omitempty" yaml:"useHostIPs,omitempty" mapstructure:"useHostIPs,omitempty"`

	// using the MY_POD_IP address for external access.
	UsePodIPs bool `json:"usePodIPs,omitempty" yaml:"usePodIPs,omitempty" mapstructure:"usePodIPs,omitempty"`
}

// Service annotations for external access
type ValuesExternalAccessControllerServiceAnnotations map[string]interface{}

// Service labels for external access
type ValuesExternalAccessControllerServiceLabels map[string]interface{}

type ValuesExternalAccessControllerServicePorts struct {
	// Kafka port used for external access when service type is LoadBalancer
	External float64 `json:"external,omitempty" yaml:"external,omitempty" mapstructure:"external,omitempty"`
}

type ValuesExternalZookeeper struct {
	// List of external zookeeper servers to use. Typically used in combination with
	// 'zookeeperChrootPath'. Must be empty if you use KRaft mode.
	Servers []interface{} `json:"servers,omitempty" yaml:"servers,omitempty" mapstructure:"servers,omitempty"`
}

type ValuesGlobal struct {
	// Compatibility corresponds to the JSON schema field "compatibility".
	Compatibility *ValuesGlobalCompatibility `json:"compatibility,omitempty" yaml:"compatibility,omitempty" mapstructure:"compatibility,omitempty"`

	// Global Docker registry secret names as an array
	ImagePullSecrets []interface{} `json:"imagePullSecrets,omitempty" yaml:"imagePullSecrets,omitempty" mapstructure:"imagePullSecrets,omitempty"`

	// Global Docker image registry
	ImageRegistry string `json:"imageRegistry,omitempty" yaml:"imageRegistry,omitempty" mapstructure:"imageRegistry,omitempty"`

	// Global StorageClass for Persistent Volume(s)
	StorageClass string `json:"storageClass,omitempty" yaml:"storageClass,omitempty" mapstructure:"storageClass,omitempty"`
}

type ValuesGlobalCompatibility struct {
	// Openshift corresponds to the JSON schema field "openshift".
	Openshift *ValuesGlobalCompatibilityOpenshift `json:"openshift,omitempty" yaml:"openshift,omitempty" mapstructure:"openshift,omitempty"`
}

type ValuesGlobalCompatibilityOpenshift struct {
	// Adapt the securityContext sections of the deployment to make them compatible
	// with Openshift restricted-v2 SCC: remove runAsUser, runAsGroup and fsGroup and
	// let the platform use their allowed default IDs. Possible values: auto (apply if
	// the detected running cluster is Openshift), force (perform the adaptation
	// always), disabled (do not perform adaptation)
	AdaptSecurityContext string `json:"adaptSecurityContext,omitempty" yaml:"adaptSecurityContext,omitempty" mapstructure:"adaptSecurityContext,omitempty"`
}

type ValuesImage struct {
	// Specify if debug values should be set
	Debug bool `json:"debug,omitempty" yaml:"debug,omitempty" mapstructure:"debug,omitempty"`

	// Kafka image digest in the way sha256:aa.... Please note this parameter, if set,
	// will override the tag
	Digest string `json:"digest,omitempty" yaml:"digest,omitempty" mapstructure:"digest,omitempty"`

	// Kafka image pull policy
	PullPolicy string `json:"pullPolicy,omitempty" yaml:"pullPolicy,omitempty" mapstructure:"pullPolicy,omitempty"`

	// Specify docker-registry secret names as an array
	PullSecrets []interface{} `json:"pullSecrets,omitempty" yaml:"pullSecrets,omitempty" mapstructure:"pullSecrets,omitempty"`

	// Kafka image registry
	Registry string `json:"registry,omitempty" yaml:"registry,omitempty" mapstructure:"registry,omitempty"`

	// Kafka image repository
	Repository string `json:"repository,omitempty" yaml:"repository,omitempty" mapstructure:"repository,omitempty"`
}

type ValuesKraft struct {
	// Kafka Kraft cluster ID. If not set, a random cluster ID will be generated the
	// first time Kraft is initialized.
	ClusterId string `json:"clusterId,omitempty" yaml:"clusterId,omitempty" mapstructure:"clusterId,omitempty"`

	// Override the Kafka controller quorum voters of the Kafka Kraft cluster. If not
	// set, it will be automatically configured to use all controller-elegible nodes.
	ControllerQuorumVoters string `json:"controllerQuorumVoters,omitempty" yaml:"controllerQuorumVoters,omitempty" mapstructure:"controllerQuorumVoters,omitempty"`

	// Switch to enable or disable the KRaft mode for Kafka
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Name of the secret containing the cluster ID for the Kafka KRaft cluster. This
	// is incompatible with the clusterId parameter. If both are set, the
	// existingClusterIdSecret will be used
	ExistingClusterIdSecret string `json:"existingClusterIdSecret,omitempty" yaml:"existingClusterIdSecret,omitempty" mapstructure:"existingClusterIdSecret,omitempty"`
}

type ValuesListeners struct {
	// Overrides the Kafka 'advertised.listener' configuration setting.
	AdvertisedListeners string `json:"advertisedListeners,omitempty" yaml:"advertisedListeners,omitempty" mapstructure:"advertisedListeners,omitempty"`

	// Client corresponds to the JSON schema field "client".
	Client *ValuesListenersClient `json:"client,omitempty" yaml:"client,omitempty" mapstructure:"client,omitempty"`

	// Controller corresponds to the JSON schema field "controller".
	Controller *ValuesListenersController `json:"controller,omitempty" yaml:"controller,omitempty" mapstructure:"controller,omitempty"`

	// External corresponds to the JSON schema field "external".
	External *ValuesListenersExternal `json:"external,omitempty" yaml:"external,omitempty" mapstructure:"external,omitempty"`

	// Array of listener objects to be appended to already existing listeners
	ExtraListeners []interface{} `json:"extraListeners,omitempty" yaml:"extraListeners,omitempty" mapstructure:"extraListeners,omitempty"`

	// Interbroker corresponds to the JSON schema field "interbroker".
	Interbroker *ValuesListenersInterbroker `json:"interbroker,omitempty" yaml:"interbroker,omitempty" mapstructure:"interbroker,omitempty"`

	// Overrides the Kafka 'listeners' configuration setting.
	OverrideListeners string `json:"overrideListeners,omitempty" yaml:"overrideListeners,omitempty" mapstructure:"overrideListeners,omitempty"`

	// Overrides the Kafka 'security.protocol.map' configuration setting.
	SecurityProtocolMap string `json:"securityProtocolMap,omitempty" yaml:"securityProtocolMap,omitempty" mapstructure:"securityProtocolMap,omitempty"`
}

type ValuesListenersClient struct {
	// Port for the Kafka client listener
	ContainerPort float64 `json:"containerPort,omitempty" yaml:"containerPort,omitempty" mapstructure:"containerPort,omitempty"`

	// Name for the Kafka client listener
	Name string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Security protocol for the Kafka client listener. Allowed values are
	// 'PLAINTEXT', 'SASL_PLAINTEXT', 'SASL_SSL' and 'SSL'
	Protocol string `json:"protocol,omitempty" yaml:"protocol,omitempty" mapstructure:"protocol,omitempty"`

	// Optional. If SASL_SSL is enabled, configure mTLS TLS authentication type. If
	// SSL protocol is enabled, overrides tls.authType for this listener. Allowed
	// values are 'none', 'requested' and 'required'
	SslClientAuth string `json:"sslClientAuth,omitempty" yaml:"sslClientAuth,omitempty" mapstructure:"sslClientAuth,omitempty"`
}

type ValuesListenersController struct {
	// Port for the Kafka controller listener
	ContainerPort float64 `json:"containerPort,omitempty" yaml:"containerPort,omitempty" mapstructure:"containerPort,omitempty"`

	// Name for the Kafka controller listener
	Name string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Security protocol for the Kafka controller listener. Allowed values are
	// 'PLAINTEXT', 'SASL_PLAINTEXT', 'SASL_SSL' and 'SSL'
	Protocol string `json:"protocol,omitempty" yaml:"protocol,omitempty" mapstructure:"protocol,omitempty"`

	// Optional. If SASL_SSL is enabled, configure mTLS TLS authentication type. If
	// SSL protocol is enabled, overrides tls.authType for this listener. Allowed
	// values are 'none', 'requested' and 'required'
	SslClientAuth string `json:"sslClientAuth,omitempty" yaml:"sslClientAuth,omitempty" mapstructure:"sslClientAuth,omitempty"`
}

type ValuesListenersExternal struct {
	// Port for the Kafka external listener
	ContainerPort float64 `json:"containerPort,omitempty" yaml:"containerPort,omitempty" mapstructure:"containerPort,omitempty"`

	// Name for the Kafka external listener
	Name string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Security protocol for the Kafka external listener. . Allowed values are
	// 'PLAINTEXT', 'SASL_PLAINTEXT', 'SASL_SSL' and 'SSL'
	Protocol string `json:"protocol,omitempty" yaml:"protocol,omitempty" mapstructure:"protocol,omitempty"`

	// Optional. If SASL_SSL is enabled, configure mTLS TLS authentication type. If
	// SSL protocol is enabled, overrides tls.sslClientAuth for this listener. Allowed
	// values are 'none', 'requested' and 'required'
	SslClientAuth string `json:"sslClientAuth,omitempty" yaml:"sslClientAuth,omitempty" mapstructure:"sslClientAuth,omitempty"`
}

type ValuesListenersInterbroker struct {
	// Port for the Kafka inter-broker listener
	ContainerPort float64 `json:"containerPort,omitempty" yaml:"containerPort,omitempty" mapstructure:"containerPort,omitempty"`

	// Name for the Kafka inter-broker listener
	Name string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Security protocol for the Kafka inter-broker listener. Allowed values are
	// 'PLAINTEXT', 'SASL_PLAINTEXT', 'SASL_SSL' and 'SSL'
	Protocol string `json:"protocol,omitempty" yaml:"protocol,omitempty" mapstructure:"protocol,omitempty"`

	// Optional. If SASL_SSL is enabled, configure mTLS TLS authentication type. If
	// SSL protocol is enabled, overrides tls.authType for this listener. Allowed
	// values are 'none', 'requested' and 'required'
	SslClientAuth string `json:"sslClientAuth,omitempty" yaml:"sslClientAuth,omitempty" mapstructure:"sslClientAuth,omitempty"`
}

type ValuesMetrics struct {
	// Jmx corresponds to the JSON schema field "jmx".
	Jmx *ValuesMetricsJmx `json:"jmx,omitempty" yaml:"jmx,omitempty" mapstructure:"jmx,omitempty"`

	// Kafka corresponds to the JSON schema field "kafka".
	Kafka *ValuesMetricsKafka `json:"kafka,omitempty" yaml:"kafka,omitempty" mapstructure:"kafka,omitempty"`

	// PrometheusRule corresponds to the JSON schema field "prometheusRule".
	PrometheusRule *ValuesMetricsPrometheusRule `json:"prometheusRule,omitempty" yaml:"prometheusRule,omitempty" mapstructure:"prometheusRule,omitempty"`

	// ServiceMonitor corresponds to the JSON schema field "serviceMonitor".
	ServiceMonitor *ValuesMetricsServiceMonitor `json:"serviceMonitor,omitempty" yaml:"serviceMonitor,omitempty" mapstructure:"serviceMonitor,omitempty"`
}

type ValuesMetricsJmx struct {
	// Configuration file for JMX exporter
	Config string `json:"config,omitempty" yaml:"config,omitempty" mapstructure:"config,omitempty"`

	// ContainerPorts corresponds to the JSON schema field "containerPorts".
	ContainerPorts *ValuesMetricsJmxContainerPorts `json:"containerPorts,omitempty" yaml:"containerPorts,omitempty" mapstructure:"containerPorts,omitempty"`

	// ContainerSecurityContext corresponds to the JSON schema field
	// "containerSecurityContext".
	ContainerSecurityContext *ValuesMetricsJmxContainerSecurityContext `json:"containerSecurityContext,omitempty" yaml:"containerSecurityContext,omitempty" mapstructure:"containerSecurityContext,omitempty"`

	// Whether or not to expose JMX metrics to Prometheus
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Name of existing ConfigMap with JMX exporter configuration
	ExistingConfigmap string `json:"existingConfigmap,omitempty" yaml:"existingConfigmap,omitempty" mapstructure:"existingConfigmap,omitempty"`

	// Add extra rules to JMX exporter configuration
	ExtraRules string `json:"extraRules,omitempty" yaml:"extraRules,omitempty" mapstructure:"extraRules,omitempty"`

	// Image corresponds to the JSON schema field "image".
	Image *ValuesMetricsJmxImage `json:"image,omitempty" yaml:"image,omitempty" mapstructure:"image,omitempty"`

	// JMX port where the exporter will collect metrics, exposed in the Kafka
	// container.
	KafkaJmxPort float64 `json:"kafkaJmxPort,omitempty" yaml:"kafkaJmxPort,omitempty" mapstructure:"kafkaJmxPort,omitempty"`

	// Set container requests and limits for different resources like CPU or memory
	// (essential for production workloads)
	Resources ValuesMetricsJmxResources `json:"resources,omitempty" yaml:"resources,omitempty" mapstructure:"resources,omitempty"`

	// Set container resources according to one common preset (allowed values: none,
	// nano, small, medium, large, xlarge, 2xlarge). This is ignored if
	// metrics.jmx.resources is set (metrics.jmx.resources is recommended for
	// production).
	ResourcesPreset string `json:"resourcesPreset,omitempty" yaml:"resourcesPreset,omitempty" mapstructure:"resourcesPreset,omitempty"`

	// Service corresponds to the JSON schema field "service".
	Service *ValuesMetricsJmxService `json:"service,omitempty" yaml:"service,omitempty" mapstructure:"service,omitempty"`

	// Allows setting which JMX objects you want to expose to via JMX stats to JMX
	// exporter
	WhitelistObjectNames []string `json:"whitelistObjectNames,omitempty" yaml:"whitelistObjectNames,omitempty" mapstructure:"whitelistObjectNames,omitempty"`
}

type ValuesMetricsJmxContainerPorts struct {
	// Prometheus JMX exporter metrics container port
	Metrics float64 `json:"metrics,omitempty" yaml:"metrics,omitempty" mapstructure:"metrics,omitempty"`
}

type ValuesMetricsJmxContainerSecurityContext struct {
	// Set Prometheus JMX exporter containers' Security Context
	// allowPrivilegeEscalation
	AllowPrivilegeEscalation bool `json:"allowPrivilegeEscalation,omitempty" yaml:"allowPrivilegeEscalation,omitempty" mapstructure:"allowPrivilegeEscalation,omitempty"`

	// Capabilities corresponds to the JSON schema field "capabilities".
	Capabilities *ValuesMetricsJmxContainerSecurityContextCapabilities `json:"capabilities,omitempty" yaml:"capabilities,omitempty" mapstructure:"capabilities,omitempty"`

	// Enable Prometheus JMX exporter containers' Security Context
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Set Prometheus JMX exporter containers' Security Context readOnlyRootFilesystem
	ReadOnlyRootFilesystem bool `json:"readOnlyRootFilesystem,omitempty" yaml:"readOnlyRootFilesystem,omitempty" mapstructure:"readOnlyRootFilesystem,omitempty"`

	// Set Prometheus JMX exporter containers' Security Context runAsNonRoot
	RunAsNonRoot bool `json:"runAsNonRoot,omitempty" yaml:"runAsNonRoot,omitempty" mapstructure:"runAsNonRoot,omitempty"`

	// Set Prometheus JMX exporter containers' Security Context runAsUser
	RunAsUser float64 `json:"runAsUser,omitempty" yaml:"runAsUser,omitempty" mapstructure:"runAsUser,omitempty"`
}

type ValuesMetricsJmxContainerSecurityContextCapabilities struct {
	// Set Prometheus JMX exporter containers' Security Context capabilities to be
	// dropped
	Drop []string `json:"drop,omitempty" yaml:"drop,omitempty" mapstructure:"drop,omitempty"`
}

type ValuesMetricsJmxImage struct {
	// JMX exporter image digest in the way sha256:aa.... Please note this parameter,
	// if set, will override the tag
	Digest string `json:"digest,omitempty" yaml:"digest,omitempty" mapstructure:"digest,omitempty"`

	// JMX exporter image pull policy
	PullPolicy string `json:"pullPolicy,omitempty" yaml:"pullPolicy,omitempty" mapstructure:"pullPolicy,omitempty"`

	// Specify docker-registry secret names as an array
	PullSecrets []interface{} `json:"pullSecrets,omitempty" yaml:"pullSecrets,omitempty" mapstructure:"pullSecrets,omitempty"`

	// JMX exporter image registry
	Registry string `json:"registry,omitempty" yaml:"registry,omitempty" mapstructure:"registry,omitempty"`

	// JMX exporter image repository
	Repository string `json:"repository,omitempty" yaml:"repository,omitempty" mapstructure:"repository,omitempty"`
}

// Set container requests and limits for different resources like CPU or memory
// (essential for production workloads)
type ValuesMetricsJmxResources map[string]interface{}

type ValuesMetricsJmxService struct {
	// Static clusterIP or None for headless services
	ClusterIP string `json:"clusterIP,omitempty" yaml:"clusterIP,omitempty" mapstructure:"clusterIP,omitempty"`

	// Ports corresponds to the JSON schema field "ports".
	Ports *ValuesMetricsJmxServicePorts `json:"ports,omitempty" yaml:"ports,omitempty" mapstructure:"ports,omitempty"`

	// Control where client requests go, to the same pod or round-robin
	SessionAffinity string `json:"sessionAffinity,omitempty" yaml:"sessionAffinity,omitempty" mapstructure:"sessionAffinity,omitempty"`
}

type ValuesMetricsJmxServicePorts struct {
	// Prometheus JMX exporter metrics service port
	Metrics float64 `json:"metrics,omitempty" yaml:"metrics,omitempty" mapstructure:"metrics,omitempty"`
}

type ValuesMetricsKafka struct {
	// Affinity for pod assignment
	Affinity ValuesMetricsKafkaAffinity `json:"affinity,omitempty" yaml:"affinity,omitempty" mapstructure:"affinity,omitempty"`

	// Override Kafka exporter container arguments
	Args []interface{} `json:"args,omitempty" yaml:"args,omitempty" mapstructure:"args,omitempty"`

	// Mount Service Account token in pod
	AutomountServiceAccountToken bool `json:"automountServiceAccountToken,omitempty" yaml:"automountServiceAccountToken,omitempty" mapstructure:"automountServiceAccountToken,omitempty"`

	// Name of the existing secret containing the optional certificate and key files
	CertificatesSecret string `json:"certificatesSecret,omitempty" yaml:"certificatesSecret,omitempty" mapstructure:"certificatesSecret,omitempty"`

	// Override Kafka exporter container command
	Command []interface{} `json:"command,omitempty" yaml:"command,omitempty" mapstructure:"command,omitempty"`

	// ContainerPorts corresponds to the JSON schema field "containerPorts".
	ContainerPorts *ValuesMetricsKafkaContainerPorts `json:"containerPorts,omitempty" yaml:"containerPorts,omitempty" mapstructure:"containerPorts,omitempty"`

	// ContainerSecurityContext corresponds to the JSON schema field
	// "containerSecurityContext".
	ContainerSecurityContext *ValuesMetricsKafkaContainerSecurityContext `json:"containerSecurityContext,omitempty" yaml:"containerSecurityContext,omitempty" mapstructure:"containerSecurityContext,omitempty"`

	// Override default liveness probe
	CustomLivenessProbe ValuesMetricsKafkaCustomLivenessProbe `json:"customLivenessProbe,omitempty" yaml:"customLivenessProbe,omitempty" mapstructure:"customLivenessProbe,omitempty"`

	// Override default readiness probe
	CustomReadinessProbe ValuesMetricsKafkaCustomReadinessProbe `json:"customReadinessProbe,omitempty" yaml:"customReadinessProbe,omitempty" mapstructure:"customReadinessProbe,omitempty"`

	// Override default startup probe
	CustomStartupProbe ValuesMetricsKafkaCustomStartupProbe `json:"customStartupProbe,omitempty" yaml:"customStartupProbe,omitempty" mapstructure:"customStartupProbe,omitempty"`

	// Whether information about services should be injected into pod's environment
	// variable
	EnableServiceLinks bool `json:"enableServiceLinks,omitempty" yaml:"enableServiceLinks,omitempty" mapstructure:"enableServiceLinks,omitempty"`

	// Whether or not to create a standalone Kafka exporter to expose Kafka metrics
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Extra flags to be passed to Kafka exporter
	ExtraFlags ValuesMetricsKafkaExtraFlags `json:"extraFlags,omitempty" yaml:"extraFlags,omitempty" mapstructure:"extraFlags,omitempty"`

	// Optionally specify extra list of additional volumeMounts for the Kafka exporter
	// container(s)
	ExtraVolumeMounts []interface{} `json:"extraVolumeMounts,omitempty" yaml:"extraVolumeMounts,omitempty" mapstructure:"extraVolumeMounts,omitempty"`

	// Optionally specify extra list of additional volumes for the Kafka exporter
	// pod(s)
	ExtraVolumes []interface{} `json:"extraVolumes,omitempty" yaml:"extraVolumes,omitempty" mapstructure:"extraVolumes,omitempty"`

	// Kafka exporter pods host aliases
	HostAliases []interface{} `json:"hostAliases,omitempty" yaml:"hostAliases,omitempty" mapstructure:"hostAliases,omitempty"`

	// Image corresponds to the JSON schema field "image".
	Image *ValuesMetricsKafkaImage `json:"image,omitempty" yaml:"image,omitempty" mapstructure:"image,omitempty"`

	// Add init containers to the Kafka exporter pods
	InitContainers []interface{} `json:"initContainers,omitempty" yaml:"initContainers,omitempty" mapstructure:"initContainers,omitempty"`

	// LivenessProbe corresponds to the JSON schema field "livenessProbe".
	LivenessProbe *ValuesMetricsKafkaLivenessProbe `json:"livenessProbe,omitempty" yaml:"livenessProbe,omitempty" mapstructure:"livenessProbe,omitempty"`

	// NodeAffinityPreset corresponds to the JSON schema field "nodeAffinityPreset".
	NodeAffinityPreset *ValuesMetricsKafkaNodeAffinityPreset `json:"nodeAffinityPreset,omitempty" yaml:"nodeAffinityPreset,omitempty" mapstructure:"nodeAffinityPreset,omitempty"`

	// Node labels for pod assignment
	NodeSelector ValuesMetricsKafkaNodeSelector `json:"nodeSelector,omitempty" yaml:"nodeSelector,omitempty" mapstructure:"nodeSelector,omitempty"`

	// Pod affinity preset. Ignored if `metrics.kafka.affinity` is set. Allowed
	// values: `soft` or `hard`
	PodAffinityPreset string `json:"podAffinityPreset,omitempty" yaml:"podAffinityPreset,omitempty" mapstructure:"podAffinityPreset,omitempty"`

	// Extra annotations for Kafka exporter pods
	PodAnnotations ValuesMetricsKafkaPodAnnotations `json:"podAnnotations,omitempty" yaml:"podAnnotations,omitempty" mapstructure:"podAnnotations,omitempty"`

	// Pod anti-affinity preset. Ignored if `metrics.kafka.affinity` is set. Allowed
	// values: `soft` or `hard`
	PodAntiAffinityPreset string `json:"podAntiAffinityPreset,omitempty" yaml:"podAntiAffinityPreset,omitempty" mapstructure:"podAntiAffinityPreset,omitempty"`

	// Extra labels for Kafka exporter pods
	PodLabels ValuesMetricsKafkaPodLabels `json:"podLabels,omitempty" yaml:"podLabels,omitempty" mapstructure:"podLabels,omitempty"`

	// PodSecurityContext corresponds to the JSON schema field "podSecurityContext".
	PodSecurityContext *ValuesMetricsKafkaPodSecurityContext `json:"podSecurityContext,omitempty" yaml:"podSecurityContext,omitempty" mapstructure:"podSecurityContext,omitempty"`

	// Kafka exporter pods' priorityClassName
	PriorityClassName string `json:"priorityClassName,omitempty" yaml:"priorityClassName,omitempty" mapstructure:"priorityClassName,omitempty"`

	// ReadinessProbe corresponds to the JSON schema field "readinessProbe".
	ReadinessProbe *ValuesMetricsKafkaReadinessProbe `json:"readinessProbe,omitempty" yaml:"readinessProbe,omitempty" mapstructure:"readinessProbe,omitempty"`

	// Set container requests and limits for different resources like CPU or memory
	// (essential for production workloads)
	Resources ValuesMetricsKafkaResources `json:"resources,omitempty" yaml:"resources,omitempty" mapstructure:"resources,omitempty"`

	// Set container resources according to one common preset (allowed values: none,
	// nano, small, medium, large, xlarge, 2xlarge). This is ignored if
	// metrics.kafka.resources is set (metrics.kafka.resources is recommended for
	// production).
	ResourcesPreset string `json:"resourcesPreset,omitempty" yaml:"resourcesPreset,omitempty" mapstructure:"resourcesPreset,omitempty"`

	// Name of the k8s scheduler (other than default) for Kafka exporter
	SchedulerName string `json:"schedulerName,omitempty" yaml:"schedulerName,omitempty" mapstructure:"schedulerName,omitempty"`

	// Service corresponds to the JSON schema field "service".
	Service *ValuesMetricsKafkaService `json:"service,omitempty" yaml:"service,omitempty" mapstructure:"service,omitempty"`

	// ServiceAccount corresponds to the JSON schema field "serviceAccount".
	ServiceAccount *ValuesMetricsKafkaServiceAccount `json:"serviceAccount,omitempty" yaml:"serviceAccount,omitempty" mapstructure:"serviceAccount,omitempty"`

	// Add additional sidecar containers to the Kafka exporter pod(s)
	Sidecars []interface{} `json:"sidecars,omitempty" yaml:"sidecars,omitempty" mapstructure:"sidecars,omitempty"`

	// StartupProbe corresponds to the JSON schema field "startupProbe".
	StartupProbe *ValuesMetricsKafkaStartupProbe `json:"startupProbe,omitempty" yaml:"startupProbe,omitempty" mapstructure:"startupProbe,omitempty"`

	// The secret key from the certificatesSecret or tlsCaSecret if 'ca-cert' key
	// different from the default (ca-file)
	TlsCaCert string `json:"tlsCaCert,omitempty" yaml:"tlsCaCert,omitempty" mapstructure:"tlsCaCert,omitempty"`

	// Name of the existing secret containing the optional ca certificate for Kafka
	// exporter client authentication
	TlsCaSecret string `json:"tlsCaSecret,omitempty" yaml:"tlsCaSecret,omitempty" mapstructure:"tlsCaSecret,omitempty"`

	// The secret key from the certificatesSecret if 'client-cert' key different from
	// the default (cert-file)
	TlsCert string `json:"tlsCert,omitempty" yaml:"tlsCert,omitempty" mapstructure:"tlsCert,omitempty"`

	// The secret key from the certificatesSecret if 'client-key' key different from
	// the default (key-file)
	TlsKey string `json:"tlsKey,omitempty" yaml:"tlsKey,omitempty" mapstructure:"tlsKey,omitempty"`

	// Tolerations for pod assignment
	Tolerations []interface{} `json:"tolerations,omitempty" yaml:"tolerations,omitempty" mapstructure:"tolerations,omitempty"`

	// Topology Spread Constraints for pod assignment
	TopologySpreadConstraints []interface{} `json:"topologySpreadConstraints,omitempty" yaml:"topologySpreadConstraints,omitempty" mapstructure:"topologySpreadConstraints,omitempty"`
}

// Affinity for pod assignment
type ValuesMetricsKafkaAffinity map[string]interface{}

type ValuesMetricsKafkaContainerPorts struct {
	// Kafka exporter metrics container port
	Metrics float64 `json:"metrics,omitempty" yaml:"metrics,omitempty" mapstructure:"metrics,omitempty"`
}

type ValuesMetricsKafkaContainerSecurityContext struct {
	// Set Kafka exporter containers' Security Context allowPrivilegeEscalation
	AllowPrivilegeEscalation bool `json:"allowPrivilegeEscalation,omitempty" yaml:"allowPrivilegeEscalation,omitempty" mapstructure:"allowPrivilegeEscalation,omitempty"`

	// Capabilities corresponds to the JSON schema field "capabilities".
	Capabilities *ValuesMetricsKafkaContainerSecurityContextCapabilities `json:"capabilities,omitempty" yaml:"capabilities,omitempty" mapstructure:"capabilities,omitempty"`

	// Enable Kafka exporter containers' Security Context
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Set Kafka exporter containers' Security Context readOnlyRootFilesystem
	ReadOnlyRootFilesystem bool `json:"readOnlyRootFilesystem,omitempty" yaml:"readOnlyRootFilesystem,omitempty" mapstructure:"readOnlyRootFilesystem,omitempty"`

	// Set Kafka exporter containers' Security Context runAsNonRoot
	RunAsNonRoot bool `json:"runAsNonRoot,omitempty" yaml:"runAsNonRoot,omitempty" mapstructure:"runAsNonRoot,omitempty"`

	// Set Kafka exporter containers' Security Context runAsUser
	RunAsUser float64 `json:"runAsUser,omitempty" yaml:"runAsUser,omitempty" mapstructure:"runAsUser,omitempty"`
}

type ValuesMetricsKafkaContainerSecurityContextCapabilities struct {
	// Set Kafka exporter containers' Security Context capabilities to be dropped
	Drop []string `json:"drop,omitempty" yaml:"drop,omitempty" mapstructure:"drop,omitempty"`
}

// Override default liveness probe
type ValuesMetricsKafkaCustomLivenessProbe map[string]interface{}

// Override default readiness probe
type ValuesMetricsKafkaCustomReadinessProbe map[string]interface{}

// Override default startup probe
type ValuesMetricsKafkaCustomStartupProbe map[string]interface{}

// Extra flags to be passed to Kafka exporter
type ValuesMetricsKafkaExtraFlags map[string]interface{}

type ValuesMetricsKafkaImage struct {
	// Kafka exporter image digest in the way sha256:aa.... Please note this
	// parameter, if set, will override the tag
	Digest string `json:"digest,omitempty" yaml:"digest,omitempty" mapstructure:"digest,omitempty"`

	// Kafka exporter image pull policy
	PullPolicy string `json:"pullPolicy,omitempty" yaml:"pullPolicy,omitempty" mapstructure:"pullPolicy,omitempty"`

	// Specify docker-registry secret names as an array
	PullSecrets []interface{} `json:"pullSecrets,omitempty" yaml:"pullSecrets,omitempty" mapstructure:"pullSecrets,omitempty"`

	// Kafka exporter image registry
	Registry string `json:"registry,omitempty" yaml:"registry,omitempty" mapstructure:"registry,omitempty"`

	// Kafka exporter image repository
	Repository string `json:"repository,omitempty" yaml:"repository,omitempty" mapstructure:"repository,omitempty"`
}

type ValuesMetricsKafkaLivenessProbe struct {
	// Enable livenessProbe
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Failure threshold for livenessProbe
	FailureThreshold float64 `json:"failureThreshold,omitempty" yaml:"failureThreshold,omitempty" mapstructure:"failureThreshold,omitempty"`

	// Initial delay seconds for livenessProbe
	InitialDelaySeconds float64 `json:"initialDelaySeconds,omitempty" yaml:"initialDelaySeconds,omitempty" mapstructure:"initialDelaySeconds,omitempty"`

	// Period seconds for livenessProbe
	PeriodSeconds float64 `json:"periodSeconds,omitempty" yaml:"periodSeconds,omitempty" mapstructure:"periodSeconds,omitempty"`

	// Success threshold for livenessProbe
	SuccessThreshold float64 `json:"successThreshold,omitempty" yaml:"successThreshold,omitempty" mapstructure:"successThreshold,omitempty"`

	// Timeout seconds for livenessProbe
	TimeoutSeconds float64 `json:"timeoutSeconds,omitempty" yaml:"timeoutSeconds,omitempty" mapstructure:"timeoutSeconds,omitempty"`
}

type ValuesMetricsKafkaNodeAffinityPreset struct {
	// Node label key to match Ignored if `metrics.kafka.affinity` is set.
	Key string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Node affinity preset type. Ignored if `metrics.kafka.affinity` is set. Allowed
	// values: `soft` or `hard`
	Type string `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`

	// Node label values to match. Ignored if `metrics.kafka.affinity` is set.
	Values []interface{} `json:"values,omitempty" yaml:"values,omitempty" mapstructure:"values,omitempty"`
}

// Node labels for pod assignment
type ValuesMetricsKafkaNodeSelector map[string]interface{}

// Extra annotations for Kafka exporter pods
type ValuesMetricsKafkaPodAnnotations map[string]interface{}

// Extra labels for Kafka exporter pods
type ValuesMetricsKafkaPodLabels map[string]interface{}

type ValuesMetricsKafkaPodSecurityContext struct {
	// Enable security context for the pods
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Set Kafka exporter pod's Security Context fsGroup
	FsGroup float64 `json:"fsGroup,omitempty" yaml:"fsGroup,omitempty" mapstructure:"fsGroup,omitempty"`

	// Set filesystem group change policy
	FsGroupChangePolicy string `json:"fsGroupChangePolicy,omitempty" yaml:"fsGroupChangePolicy,omitempty" mapstructure:"fsGroupChangePolicy,omitempty"`

	// SeccompProfile corresponds to the JSON schema field "seccompProfile".
	SeccompProfile *ValuesMetricsKafkaPodSecurityContextSeccompProfile `json:"seccompProfile,omitempty" yaml:"seccompProfile,omitempty" mapstructure:"seccompProfile,omitempty"`

	// Set filesystem extra groups
	SupplementalGroups []interface{} `json:"supplementalGroups,omitempty" yaml:"supplementalGroups,omitempty" mapstructure:"supplementalGroups,omitempty"`

	// Set kernel settings using the sysctl interface
	Sysctls []interface{} `json:"sysctls,omitempty" yaml:"sysctls,omitempty" mapstructure:"sysctls,omitempty"`
}

type ValuesMetricsKafkaPodSecurityContextSeccompProfile struct {
	// Set Kafka exporter pod's Security Context seccomp profile
	Type string `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`
}

type ValuesMetricsKafkaReadinessProbe struct {
	// Enable readinessProbe
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Failure threshold for readinessProbe
	FailureThreshold float64 `json:"failureThreshold,omitempty" yaml:"failureThreshold,omitempty" mapstructure:"failureThreshold,omitempty"`

	// Initial delay seconds for readinessProbe
	InitialDelaySeconds float64 `json:"initialDelaySeconds,omitempty" yaml:"initialDelaySeconds,omitempty" mapstructure:"initialDelaySeconds,omitempty"`

	// Period seconds for readinessProbe
	PeriodSeconds float64 `json:"periodSeconds,omitempty" yaml:"periodSeconds,omitempty" mapstructure:"periodSeconds,omitempty"`

	// Success threshold for readinessProbe
	SuccessThreshold float64 `json:"successThreshold,omitempty" yaml:"successThreshold,omitempty" mapstructure:"successThreshold,omitempty"`

	// Timeout seconds for readinessProbe
	TimeoutSeconds float64 `json:"timeoutSeconds,omitempty" yaml:"timeoutSeconds,omitempty" mapstructure:"timeoutSeconds,omitempty"`
}

// Set container requests and limits for different resources like CPU or memory
// (essential for production workloads)
type ValuesMetricsKafkaResources map[string]interface{}

type ValuesMetricsKafkaService struct {
	// Static clusterIP or None for headless services
	ClusterIP string `json:"clusterIP,omitempty" yaml:"clusterIP,omitempty" mapstructure:"clusterIP,omitempty"`

	// Ports corresponds to the JSON schema field "ports".
	Ports *ValuesMetricsKafkaServicePorts `json:"ports,omitempty" yaml:"ports,omitempty" mapstructure:"ports,omitempty"`

	// Control where client requests go, to the same pod or round-robin
	SessionAffinity string `json:"sessionAffinity,omitempty" yaml:"sessionAffinity,omitempty" mapstructure:"sessionAffinity,omitempty"`
}

type ValuesMetricsKafkaServiceAccount struct {
	// Allows auto mount of ServiceAccountToken on the serviceAccount created
	AutomountServiceAccountToken bool `json:"automountServiceAccountToken,omitempty" yaml:"automountServiceAccountToken,omitempty" mapstructure:"automountServiceAccountToken,omitempty"`

	// Enable creation of ServiceAccount for Kafka exporter pods
	Create bool `json:"create,omitempty" yaml:"create,omitempty" mapstructure:"create,omitempty"`

	// The name of the service account to use. If not set and `create` is `true`, a
	// name is generated
	Name string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`
}

type ValuesMetricsKafkaServicePorts struct {
	// Kafka exporter metrics service port
	Metrics float64 `json:"metrics,omitempty" yaml:"metrics,omitempty" mapstructure:"metrics,omitempty"`
}

type ValuesMetricsKafkaStartupProbe struct {
	// Enable startupProbe
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Failure threshold for startupProbe
	FailureThreshold float64 `json:"failureThreshold,omitempty" yaml:"failureThreshold,omitempty" mapstructure:"failureThreshold,omitempty"`

	// Initial delay seconds for startupProbe
	InitialDelaySeconds float64 `json:"initialDelaySeconds,omitempty" yaml:"initialDelaySeconds,omitempty" mapstructure:"initialDelaySeconds,omitempty"`

	// Period seconds for startupProbe
	PeriodSeconds float64 `json:"periodSeconds,omitempty" yaml:"periodSeconds,omitempty" mapstructure:"periodSeconds,omitempty"`

	// Success threshold for startupProbe
	SuccessThreshold float64 `json:"successThreshold,omitempty" yaml:"successThreshold,omitempty" mapstructure:"successThreshold,omitempty"`

	// Timeout seconds for startupProbe
	TimeoutSeconds float64 `json:"timeoutSeconds,omitempty" yaml:"timeoutSeconds,omitempty" mapstructure:"timeoutSeconds,omitempty"`
}

type ValuesMetricsPrometheusRule struct {
	// if `true`, creates a Prometheus Operator PrometheusRule (requires
	// `metrics.kafka.enabled` or `metrics.jmx.enabled` to be `true`)
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Prometheus Rule Groups for Kafka
	Groups []interface{} `json:"groups,omitempty" yaml:"groups,omitempty" mapstructure:"groups,omitempty"`

	// Additional labels that can be used so PrometheusRule will be discovered by
	// Prometheus
	Labels ValuesMetricsPrometheusRuleLabels `json:"labels,omitempty" yaml:"labels,omitempty" mapstructure:"labels,omitempty"`

	// Namespace in which Prometheus is running
	Namespace string `json:"namespace,omitempty" yaml:"namespace,omitempty" mapstructure:"namespace,omitempty"`
}

// Additional labels that can be used so PrometheusRule will be discovered by
// Prometheus
type ValuesMetricsPrometheusRuleLabels map[string]interface{}

type ValuesMetricsServiceMonitor struct {
	// if `true`, creates a Prometheus Operator ServiceMonitor (requires
	// `metrics.kafka.enabled` or `metrics.jmx.enabled` to be `true`)
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Specify honorLabels parameter to add the scrape endpoint
	HonorLabels bool `json:"honorLabels,omitempty" yaml:"honorLabels,omitempty" mapstructure:"honorLabels,omitempty"`

	// Interval at which metrics should be scraped
	Interval string `json:"interval,omitempty" yaml:"interval,omitempty" mapstructure:"interval,omitempty"`

	// The name of the label on the target service to use as the job name in
	// prometheus.
	JobLabel string `json:"jobLabel,omitempty" yaml:"jobLabel,omitempty" mapstructure:"jobLabel,omitempty"`

	// Additional labels that can be used so ServiceMonitor will be discovered by
	// Prometheus
	Labels ValuesMetricsServiceMonitorLabels `json:"labels,omitempty" yaml:"labels,omitempty" mapstructure:"labels,omitempty"`

	// MetricRelabelConfigs to apply to samples before ingestion
	MetricRelabelings []interface{} `json:"metricRelabelings,omitempty" yaml:"metricRelabelings,omitempty" mapstructure:"metricRelabelings,omitempty"`

	// Namespace in which Prometheus is running
	Namespace string `json:"namespace,omitempty" yaml:"namespace,omitempty" mapstructure:"namespace,omitempty"`

	// RelabelConfigs to apply to samples before scraping
	Relabelings []interface{} `json:"relabelings,omitempty" yaml:"relabelings,omitempty" mapstructure:"relabelings,omitempty"`

	// Timeout after which the scrape is ended
	ScrapeTimeout string `json:"scrapeTimeout,omitempty" yaml:"scrapeTimeout,omitempty" mapstructure:"scrapeTimeout,omitempty"`

	// Prometheus instance selector labels
	Selector ValuesMetricsServiceMonitorSelector `json:"selector,omitempty" yaml:"selector,omitempty" mapstructure:"selector,omitempty"`
}

// Additional labels that can be used so ServiceMonitor will be discovered by
// Prometheus
type ValuesMetricsServiceMonitorLabels map[string]interface{}

// Prometheus instance selector labels
type ValuesMetricsServiceMonitorSelector map[string]interface{}

type ValuesNetworkPolicy struct {
	// Don't require client label for connections
	AllowExternal bool `json:"allowExternal,omitempty" yaml:"allowExternal,omitempty" mapstructure:"allowExternal,omitempty"`

	// Specifies whether a NetworkPolicy should be created
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// A Kubernetes LabelSelector to explicitly select namespaces from which traffic
	// could be allowed
	ExplicitNamespacesSelector ValuesNetworkPolicyExplicitNamespacesSelector `json:"explicitNamespacesSelector,omitempty" yaml:"explicitNamespacesSelector,omitempty" mapstructure:"explicitNamespacesSelector,omitempty"`

	// ExternalAccess corresponds to the JSON schema field "externalAccess".
	ExternalAccess *ValuesNetworkPolicyExternalAccess `json:"externalAccess,omitempty" yaml:"externalAccess,omitempty" mapstructure:"externalAccess,omitempty"`
}

// A Kubernetes LabelSelector to explicitly select namespaces from which traffic
// could be allowed
type ValuesNetworkPolicyExplicitNamespacesSelector map[string]interface{}

type ValuesNetworkPolicyExternalAccess struct {
	// customize the from section for External Access on tcp-external port
	From []interface{} `json:"from,omitempty" yaml:"from,omitempty" mapstructure:"from,omitempty"`
}

type ValuesProvisioning struct {
	// Override provisioning container arguments
	Args []interface{} `json:"args,omitempty" yaml:"args,omitempty" mapstructure:"args,omitempty"`

	// Auth corresponds to the JSON schema field "auth".
	Auth *ValuesProvisioningAuth `json:"auth,omitempty" yaml:"auth,omitempty" mapstructure:"auth,omitempty"`

	// Mount Service Account token in pod
	AutomountServiceAccountToken bool `json:"automountServiceAccountToken,omitempty" yaml:"automountServiceAccountToken,omitempty" mapstructure:"automountServiceAccountToken,omitempty"`

	// Override provisioning container command
	Command []interface{} `json:"command,omitempty" yaml:"command,omitempty" mapstructure:"command,omitempty"`

	// ContainerSecurityContext corresponds to the JSON schema field
	// "containerSecurityContext".
	ContainerSecurityContext *ValuesProvisioningContainerSecurityContext `json:"containerSecurityContext,omitempty" yaml:"containerSecurityContext,omitempty" mapstructure:"containerSecurityContext,omitempty"`

	// Whether information about services should be injected into pod's environment
	// variable
	EnableServiceLinks bool `json:"enableServiceLinks,omitempty" yaml:"enableServiceLinks,omitempty" mapstructure:"enableServiceLinks,omitempty"`

	// Enable kafka provisioning Job
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Extra environment variables to add to the provisioning pod
	ExtraEnvVars []interface{} `json:"extraEnvVars,omitempty" yaml:"extraEnvVars,omitempty" mapstructure:"extraEnvVars,omitempty"`

	// ConfigMap with extra environment variables
	ExtraEnvVarsCM string `json:"extraEnvVarsCM,omitempty" yaml:"extraEnvVarsCM,omitempty" mapstructure:"extraEnvVarsCM,omitempty"`

	// Secret with extra environment variables
	ExtraEnvVarsSecret string `json:"extraEnvVarsSecret,omitempty" yaml:"extraEnvVarsSecret,omitempty" mapstructure:"extraEnvVarsSecret,omitempty"`

	// Extra commands to run to provision cluster resources
	ExtraProvisioningCommands []interface{} `json:"extraProvisioningCommands,omitempty" yaml:"extraProvisioningCommands,omitempty" mapstructure:"extraProvisioningCommands,omitempty"`

	// Optionally specify extra list of additional volumeMounts for the Kafka
	// provisioning container(s)
	ExtraVolumeMounts []interface{} `json:"extraVolumeMounts,omitempty" yaml:"extraVolumeMounts,omitempty" mapstructure:"extraVolumeMounts,omitempty"`

	// Optionally specify extra list of additional volumes for the Kafka provisioning
	// pod(s)
	ExtraVolumes []interface{} `json:"extraVolumes,omitempty" yaml:"extraVolumes,omitempty" mapstructure:"extraVolumes,omitempty"`

	// Add additional Add init containers to the Kafka provisioning pod(s)
	InitContainers []interface{} `json:"initContainers,omitempty" yaml:"initContainers,omitempty" mapstructure:"initContainers,omitempty"`

	// Node labels for pod assignment
	NodeSelector ValuesProvisioningNodeSelector `json:"nodeSelector,omitempty" yaml:"nodeSelector,omitempty" mapstructure:"nodeSelector,omitempty"`

	// Default number of partitions for topics when unspecified
	NumPartitions float64 `json:"numPartitions,omitempty" yaml:"numPartitions,omitempty" mapstructure:"numPartitions,omitempty"`

	// Number of provisioning commands to run at the same time
	Parallel float64 `json:"parallel,omitempty" yaml:"parallel,omitempty" mapstructure:"parallel,omitempty"`

	// Extra annotations for Kafka provisioning pods
	PodAnnotations ValuesProvisioningPodAnnotations `json:"podAnnotations,omitempty" yaml:"podAnnotations,omitempty" mapstructure:"podAnnotations,omitempty"`

	// Extra labels for Kafka provisioning pods
	PodLabels ValuesProvisioningPodLabels `json:"podLabels,omitempty" yaml:"podLabels,omitempty" mapstructure:"podLabels,omitempty"`

	// PodSecurityContext corresponds to the JSON schema field "podSecurityContext".
	PodSecurityContext *ValuesProvisioningPodSecurityContext `json:"podSecurityContext,omitempty" yaml:"podSecurityContext,omitempty" mapstructure:"podSecurityContext,omitempty"`

	// Extra bash script to run after topic provisioning. $CLIENT_CONF is path to
	// properties file with most needed configurations
	PostScript string `json:"postScript,omitempty" yaml:"postScript,omitempty" mapstructure:"postScript,omitempty"`

	// Extra bash script to run before topic provisioning. $CLIENT_CONF is path to
	// properties file with most needed configurations
	PreScript string `json:"preScript,omitempty" yaml:"preScript,omitempty" mapstructure:"preScript,omitempty"`

	// Default replication factor for topics when unspecified
	ReplicationFactor float64 `json:"replicationFactor,omitempty" yaml:"replicationFactor,omitempty" mapstructure:"replicationFactor,omitempty"`

	// Set container requests and limits for different resources like CPU or memory
	// (essential for production workloads)
	Resources ValuesProvisioningResources `json:"resources,omitempty" yaml:"resources,omitempty" mapstructure:"resources,omitempty"`

	// Set container resources according to one common preset (allowed values: none,
	// nano, small, medium, large, xlarge, 2xlarge). This is ignored if
	// provisioning.resources is set (provisioning.resources is recommended for
	// production).
	ResourcesPreset string `json:"resourcesPreset,omitempty" yaml:"resourcesPreset,omitempty" mapstructure:"resourcesPreset,omitempty"`

	// Name of the k8s scheduler (other than default) for kafka provisioning
	SchedulerName string `json:"schedulerName,omitempty" yaml:"schedulerName,omitempty" mapstructure:"schedulerName,omitempty"`

	// ServiceAccount corresponds to the JSON schema field "serviceAccount".
	ServiceAccount *ValuesProvisioningServiceAccount `json:"serviceAccount,omitempty" yaml:"serviceAccount,omitempty" mapstructure:"serviceAccount,omitempty"`

	// Add additional sidecar containers to the Kafka provisioning pod(s)
	Sidecars []interface{} `json:"sidecars,omitempty" yaml:"sidecars,omitempty" mapstructure:"sidecars,omitempty"`

	// Tolerations for pod assignment
	Tolerations []interface{} `json:"tolerations,omitempty" yaml:"tolerations,omitempty" mapstructure:"tolerations,omitempty"`

	// Kafka topics to provision
	Topics []interface{} `json:"topics,omitempty" yaml:"topics,omitempty" mapstructure:"topics,omitempty"`

	// Flag to indicate usage of helm hooks
	UseHelmHooks bool `json:"useHelmHooks,omitempty" yaml:"useHelmHooks,omitempty" mapstructure:"useHelmHooks,omitempty"`

	// If true use an init container to wait until kafka is ready before starting
	// provisioning
	WaitForKafka bool `json:"waitForKafka,omitempty" yaml:"waitForKafka,omitempty" mapstructure:"waitForKafka,omitempty"`
}

type ValuesProvisioningAuth struct {
	// Tls corresponds to the JSON schema field "tls".
	Tls *ValuesProvisioningAuthTls `json:"tls,omitempty" yaml:"tls,omitempty" mapstructure:"tls,omitempty"`
}

type ValuesProvisioningAuthTls struct {
	// The secret key from the certificatesSecret if 'caCert' key different from the
	// default (ca.crt)
	CaCert string `json:"caCert,omitempty" yaml:"caCert,omitempty" mapstructure:"caCert,omitempty"`

	// The secret key from the certificatesSecret if 'cert' key different from the
	// default (tls.crt)
	Cert string `json:"cert,omitempty" yaml:"cert,omitempty" mapstructure:"cert,omitempty"`

	// Existing secret containing the TLS certificates for the Kafka provisioning Job.
	CertificatesSecret string `json:"certificatesSecret,omitempty" yaml:"certificatesSecret,omitempty" mapstructure:"certificatesSecret,omitempty"`

	// The secret key from the certificatesSecret if 'key' key different from the
	// default (tls.key)
	Key string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Password to access the password-protected PEM key if necessary. Ignored if
	// 'passwordsSecret' is provided.
	KeyPassword string `json:"keyPassword,omitempty" yaml:"keyPassword,omitempty" mapstructure:"keyPassword,omitempty"`

	// The secret key from the passwordsSecret if 'keyPasswordSecretKey' key different
	// from the default (key-password)
	KeyPasswordSecretKey string `json:"keyPasswordSecretKey,omitempty" yaml:"keyPasswordSecretKey,omitempty" mapstructure:"keyPasswordSecretKey,omitempty"`

	// The secret key from the certificatesSecret if 'keystore' key different from the
	// default (keystore.jks)
	Keystore string `json:"keystore,omitempty" yaml:"keystore,omitempty" mapstructure:"keystore,omitempty"`

	// Password to access the JKS keystore. Ignored if 'passwordsSecret' is provided.
	KeystorePassword string `json:"keystorePassword,omitempty" yaml:"keystorePassword,omitempty" mapstructure:"keystorePassword,omitempty"`

	// The secret key from the passwordsSecret if 'keystorePasswordSecretKey' key
	// different from the default (keystore-password)
	KeystorePasswordSecretKey string `json:"keystorePasswordSecretKey,omitempty" yaml:"keystorePasswordSecretKey,omitempty" mapstructure:"keystorePasswordSecretKey,omitempty"`

	// Name of the secret containing passwords to access the JKS files or PEM key when
	// they are password-protected.
	PasswordsSecret string `json:"passwordsSecret,omitempty" yaml:"passwordsSecret,omitempty" mapstructure:"passwordsSecret,omitempty"`

	// The secret key from the certificatesSecret if 'truststore' key different from
	// the default (truststore.jks)
	Truststore string `json:"truststore,omitempty" yaml:"truststore,omitempty" mapstructure:"truststore,omitempty"`

	// Password to access the JKS truststore. Ignored if 'passwordsSecret' is
	// provided.
	TruststorePassword string `json:"truststorePassword,omitempty" yaml:"truststorePassword,omitempty" mapstructure:"truststorePassword,omitempty"`

	// The secret key from the passwordsSecret if 'truststorePasswordSecretKey' key
	// different from the default (truststore-password)
	TruststorePasswordSecretKey string `json:"truststorePasswordSecretKey,omitempty" yaml:"truststorePasswordSecretKey,omitempty" mapstructure:"truststorePasswordSecretKey,omitempty"`

	// Format to use for TLS certificates. Allowed types: `JKS` and `PEM`.
	Type string `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`
}

type ValuesProvisioningContainerSecurityContext struct {
	// Set Kafka provisioning containers' Security Context allowPrivilegeEscalation
	AllowPrivilegeEscalation bool `json:"allowPrivilegeEscalation,omitempty" yaml:"allowPrivilegeEscalation,omitempty" mapstructure:"allowPrivilegeEscalation,omitempty"`

	// Capabilities corresponds to the JSON schema field "capabilities".
	Capabilities *ValuesProvisioningContainerSecurityContextCapabilities `json:"capabilities,omitempty" yaml:"capabilities,omitempty" mapstructure:"capabilities,omitempty"`

	// Enable Kafka provisioning containers' Security Context
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Set Kafka provisioning containers' Security Context readOnlyRootFilesystem
	ReadOnlyRootFilesystem bool `json:"readOnlyRootFilesystem,omitempty" yaml:"readOnlyRootFilesystem,omitempty" mapstructure:"readOnlyRootFilesystem,omitempty"`

	// Set Kafka provisioning containers' Security Context runAsNonRoot
	RunAsNonRoot bool `json:"runAsNonRoot,omitempty" yaml:"runAsNonRoot,omitempty" mapstructure:"runAsNonRoot,omitempty"`

	// Set Kafka provisioning containers' Security Context runAsUser
	RunAsUser float64 `json:"runAsUser,omitempty" yaml:"runAsUser,omitempty" mapstructure:"runAsUser,omitempty"`
}

type ValuesProvisioningContainerSecurityContextCapabilities struct {
	// Set Kafka provisioning containers' Security Context capabilities to be dropped
	Drop []string `json:"drop,omitempty" yaml:"drop,omitempty" mapstructure:"drop,omitempty"`
}

// Node labels for pod assignment
type ValuesProvisioningNodeSelector map[string]interface{}

// Extra annotations for Kafka provisioning pods
type ValuesProvisioningPodAnnotations map[string]interface{}

// Extra labels for Kafka provisioning pods
type ValuesProvisioningPodLabels map[string]interface{}

type ValuesProvisioningPodSecurityContext struct {
	// Enable security context for the pods
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Set Kafka provisioning pod's Security Context fsGroup
	FsGroup float64 `json:"fsGroup,omitempty" yaml:"fsGroup,omitempty" mapstructure:"fsGroup,omitempty"`

	// Set filesystem group change policy
	FsGroupChangePolicy string `json:"fsGroupChangePolicy,omitempty" yaml:"fsGroupChangePolicy,omitempty" mapstructure:"fsGroupChangePolicy,omitempty"`

	// SeccompProfile corresponds to the JSON schema field "seccompProfile".
	SeccompProfile *ValuesProvisioningPodSecurityContextSeccompProfile `json:"seccompProfile,omitempty" yaml:"seccompProfile,omitempty" mapstructure:"seccompProfile,omitempty"`

	// Set filesystem extra groups
	SupplementalGroups []interface{} `json:"supplementalGroups,omitempty" yaml:"supplementalGroups,omitempty" mapstructure:"supplementalGroups,omitempty"`

	// Set kernel settings using the sysctl interface
	Sysctls []interface{} `json:"sysctls,omitempty" yaml:"sysctls,omitempty" mapstructure:"sysctls,omitempty"`
}

type ValuesProvisioningPodSecurityContextSeccompProfile struct {
	// Set Kafka provisioning pod's Security Context seccomp profile
	Type string `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`
}

// Set container requests and limits for different resources like CPU or memory
// (essential for production workloads)
type ValuesProvisioningResources map[string]interface{}

type ValuesProvisioningServiceAccount struct {
	// Allows auto mount of ServiceAccountToken on the serviceAccount created
	AutomountServiceAccountToken bool `json:"automountServiceAccountToken,omitempty" yaml:"automountServiceAccountToken,omitempty" mapstructure:"automountServiceAccountToken,omitempty"`

	// Enable creation of ServiceAccount for Kafka provisioning pods
	Create bool `json:"create,omitempty" yaml:"create,omitempty" mapstructure:"create,omitempty"`

	// The name of the service account to use. If not set and `create` is `true`, a
	// name is generated
	Name string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`
}

type ValuesRbac struct {
	// Whether to create & use RBAC resources or not
	Create bool `json:"create,omitempty" yaml:"create,omitempty" mapstructure:"create,omitempty"`
}

type ValuesSasl struct {
	// Client corresponds to the JSON schema field "client".
	Client *ValuesSaslClient `json:"client,omitempty" yaml:"client,omitempty" mapstructure:"client,omitempty"`

	// Controller corresponds to the JSON schema field "controller".
	Controller *ValuesSaslController `json:"controller,omitempty" yaml:"controller,omitempty" mapstructure:"controller,omitempty"`

	// SASL mechanism for controller communications.
	ControllerMechanism string `json:"controllerMechanism,omitempty" yaml:"controllerMechanism,omitempty" mapstructure:"controllerMechanism,omitempty"`

	// Comma-separated list of allowed SASL mechanisms when SASL listeners are
	// configured. Allowed types: `PLAIN`, `SCRAM-SHA-256`, `SCRAM-SHA-512`,
	// `OAUTHBEARER`
	EnabledMechanisms string `json:"enabledMechanisms,omitempty" yaml:"enabledMechanisms,omitempty" mapstructure:"enabledMechanisms,omitempty"`

	// Name of the existing secret containing credentials for clientUsers,
	// interBrokerUser, controllerUser and zookeeperUser
	ExistingSecret string `json:"existingSecret,omitempty" yaml:"existingSecret,omitempty" mapstructure:"existingSecret,omitempty"`

	// SASL mechanism for inter broker communication.
	InterBrokerMechanism string `json:"interBrokerMechanism,omitempty" yaml:"interBrokerMechanism,omitempty" mapstructure:"interBrokerMechanism,omitempty"`

	// Interbroker corresponds to the JSON schema field "interbroker".
	Interbroker *ValuesSaslInterbroker `json:"interbroker,omitempty" yaml:"interbroker,omitempty" mapstructure:"interbroker,omitempty"`

	// Oauthbearer corresponds to the JSON schema field "oauthbearer".
	Oauthbearer *ValuesSaslOauthbearer `json:"oauthbearer,omitempty" yaml:"oauthbearer,omitempty" mapstructure:"oauthbearer,omitempty"`

	// Zookeeper corresponds to the JSON schema field "zookeeper".
	Zookeeper *ValuesSaslZookeeper `json:"zookeeper,omitempty" yaml:"zookeeper,omitempty" mapstructure:"zookeeper,omitempty"`
}

type ValuesSaslClient struct {
	// Comma-separated list of passwords for client communications when SASL is
	// enabled, must match the number of client.users
	Passwords string `json:"passwords,omitempty" yaml:"passwords,omitempty" mapstructure:"passwords,omitempty"`

	// Comma-separated list of usernames for client communications when SASL is
	// enabled
	Users []string `json:"users,omitempty" yaml:"users,omitempty" mapstructure:"users,omitempty"`
}

type ValuesSaslController struct {
	// Client ID for controller communications when SASL is enabled with mechanism
	// OAUTHBEARER
	ClientId string `json:"clientId,omitempty" yaml:"clientId,omitempty" mapstructure:"clientId,omitempty"`

	// Client Secret for controller communications when SASL is enabled with mechanism
	// OAUTHBEARER. If not set and SASL is enabled for the inter-broker listener, a
	// random secret will be generated.
	ClientSecret string `json:"clientSecret,omitempty" yaml:"clientSecret,omitempty" mapstructure:"clientSecret,omitempty"`

	// Password for controller communications when SASL is enabled. If not set and
	// SASL is enabled for the inter-broker listener, a random password will be
	// generated.
	Password string `json:"password,omitempty" yaml:"password,omitempty" mapstructure:"password,omitempty"`

	// Username for controller communications when SASL is enabled
	User string `json:"user,omitempty" yaml:"user,omitempty" mapstructure:"user,omitempty"`
}

type ValuesSaslInterbroker struct {
	// Client ID for inter-broker communications when SASL is enabled with mechanism
	// OAUTHBEARER
	ClientId string `json:"clientId,omitempty" yaml:"clientId,omitempty" mapstructure:"clientId,omitempty"`

	// Client Secret for inter-broker communications when SASL is enabled with
	// mechanism OAUTHBEARER. If not set and SASL is enabled for the controller
	// listener, a random secret will be generated.
	ClientSecret string `json:"clientSecret,omitempty" yaml:"clientSecret,omitempty" mapstructure:"clientSecret,omitempty"`

	// Password for inter-broker communications when SASL is enabled. If not set and
	// SASL is enabled for the controller listener, a random password will be
	// generated.
	Password string `json:"password,omitempty" yaml:"password,omitempty" mapstructure:"password,omitempty"`

	// Username for inter-broker communications when SASL is enabled
	User string `json:"user,omitempty" yaml:"user,omitempty" mapstructure:"user,omitempty"`
}

type ValuesSaslOauthbearer struct {
	// The comma-delimited setting for the broker to use to verify that the JWT was
	// issued for one of the expected audiences
	ExpectedAudience string `json:"expectedAudience,omitempty" yaml:"expectedAudience,omitempty" mapstructure:"expectedAudience,omitempty"`

	// The OAuth/OIDC provider URL from which the provider's JWKS (JSON Web Key Set)
	// can be retrieved
	JwksEndpointUrl string `json:"jwksEndpointUrl,omitempty" yaml:"jwksEndpointUrl,omitempty" mapstructure:"jwksEndpointUrl,omitempty"`

	// The OAuth claim name for the subject.
	SubClaimName string `json:"subClaimName,omitempty" yaml:"subClaimName,omitempty" mapstructure:"subClaimName,omitempty"`

	// The URL for the OAuth/OIDC identity provider
	TokenEndpointUrl string `json:"tokenEndpointUrl,omitempty" yaml:"tokenEndpointUrl,omitempty" mapstructure:"tokenEndpointUrl,omitempty"`
}

type ValuesSaslZookeeper struct {
	// Password for zookeeper communications when SASL is enabled.
	Password string `json:"password,omitempty" yaml:"password,omitempty" mapstructure:"password,omitempty"`

	// Username for zookeeper communications when SASL is enabled.
	User string `json:"user,omitempty" yaml:"user,omitempty" mapstructure:"user,omitempty"`
}

type ValuesService struct {
	// Whether to allocate node ports when service type is LoadBalancer
	AllocateLoadBalancerNodePorts bool `json:"allocateLoadBalancerNodePorts,omitempty" yaml:"allocateLoadBalancerNodePorts,omitempty" mapstructure:"allocateLoadBalancerNodePorts,omitempty"`

	// Additional custom annotations for Kafka service
	Annotations ValuesServiceAnnotations `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Kafka service Cluster IP
	ClusterIP string `json:"clusterIP,omitempty" yaml:"clusterIP,omitempty" mapstructure:"clusterIP,omitempty"`

	// Kafka service external traffic policy
	ExternalTrafficPolicy string `json:"externalTrafficPolicy,omitempty" yaml:"externalTrafficPolicy,omitempty" mapstructure:"externalTrafficPolicy,omitempty"`

	// Extra ports to expose in the Kafka service (normally used with the `sidecar`
	// value)
	ExtraPorts []interface{} `json:"extraPorts,omitempty" yaml:"extraPorts,omitempty" mapstructure:"extraPorts,omitempty"`

	// Headless corresponds to the JSON schema field "headless".
	Headless *ValuesServiceHeadless `json:"headless,omitempty" yaml:"headless,omitempty" mapstructure:"headless,omitempty"`

	// Kafka service Load Balancer IP
	LoadBalancerIP string `json:"loadBalancerIP,omitempty" yaml:"loadBalancerIP,omitempty" mapstructure:"loadBalancerIP,omitempty"`

	// Kafka service Load Balancer sources
	LoadBalancerSourceRanges []interface{} `json:"loadBalancerSourceRanges,omitempty" yaml:"loadBalancerSourceRanges,omitempty" mapstructure:"loadBalancerSourceRanges,omitempty"`

	// NodePorts corresponds to the JSON schema field "nodePorts".
	NodePorts *ValuesServiceNodePorts `json:"nodePorts,omitempty" yaml:"nodePorts,omitempty" mapstructure:"nodePorts,omitempty"`

	// Ports corresponds to the JSON schema field "ports".
	Ports *ValuesServicePorts `json:"ports,omitempty" yaml:"ports,omitempty" mapstructure:"ports,omitempty"`

	// Control where client requests go, to the same pod or round-robin
	SessionAffinity string `json:"sessionAffinity,omitempty" yaml:"sessionAffinity,omitempty" mapstructure:"sessionAffinity,omitempty"`

	// Additional settings for the sessionAffinity
	SessionAffinityConfig ValuesServiceSessionAffinityConfig `json:"sessionAffinityConfig,omitempty" yaml:"sessionAffinityConfig,omitempty" mapstructure:"sessionAffinityConfig,omitempty"`

	// Kubernetes Service type
	Type string `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`
}

type ValuesServiceAccount struct {
	// Additional custom annotations for the ServiceAccount
	Annotations ValuesServiceAccountAnnotations `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Allows auto mount of ServiceAccountToken on the serviceAccount created
	AutomountServiceAccountToken bool `json:"automountServiceAccountToken,omitempty" yaml:"automountServiceAccountToken,omitempty" mapstructure:"automountServiceAccountToken,omitempty"`

	// Enable creation of ServiceAccount for Kafka pods
	Create bool `json:"create,omitempty" yaml:"create,omitempty" mapstructure:"create,omitempty"`

	// The name of the service account to use. If not set and `create` is `true`, a
	// name is generated
	Name string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`
}

// Additional custom annotations for the ServiceAccount
type ValuesServiceAccountAnnotations map[string]interface{}

// Additional custom annotations for Kafka service
type ValuesServiceAnnotations map[string]interface{}

type ValuesServiceBindings struct {
	// Create secret for service binding (Experimental)
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`
}

type ValuesServiceHeadless struct {
	// Broker corresponds to the JSON schema field "broker".
	Broker *ValuesServiceHeadlessBroker `json:"broker,omitempty" yaml:"broker,omitempty" mapstructure:"broker,omitempty"`

	// Controller corresponds to the JSON schema field "controller".
	Controller *ValuesServiceHeadlessController `json:"controller,omitempty" yaml:"controller,omitempty" mapstructure:"controller,omitempty"`
}

type ValuesServiceHeadlessBroker struct {
	// Annotations for the broker-only headless service.
	Annotations ValuesServiceHeadlessBrokerAnnotations `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Labels for the broker-only headless service.
	Labels ValuesServiceHeadlessBrokerLabels `json:"labels,omitempty" yaml:"labels,omitempty" mapstructure:"labels,omitempty"`
}

// Annotations for the broker-only headless service.
type ValuesServiceHeadlessBrokerAnnotations map[string]interface{}

// Labels for the broker-only headless service.
type ValuesServiceHeadlessBrokerLabels map[string]interface{}

type ValuesServiceHeadlessController struct {
	// Annotations for the controller-eligible headless service.
	Annotations ValuesServiceHeadlessControllerAnnotations `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Labels for the controller-eligible headless service.
	Labels ValuesServiceHeadlessControllerLabels `json:"labels,omitempty" yaml:"labels,omitempty" mapstructure:"labels,omitempty"`
}

// Annotations for the controller-eligible headless service.
type ValuesServiceHeadlessControllerAnnotations map[string]interface{}

// Labels for the controller-eligible headless service.
type ValuesServiceHeadlessControllerLabels map[string]interface{}

type ValuesServiceNodePorts struct {
	// Node port for the Kafka client connections
	Client string `json:"client,omitempty" yaml:"client,omitempty" mapstructure:"client,omitempty"`

	// Node port for the Kafka external connections
	External string `json:"external,omitempty" yaml:"external,omitempty" mapstructure:"external,omitempty"`
}

type ValuesServicePorts struct {
	// Kafka svc port for client connections
	Client float64 `json:"client,omitempty" yaml:"client,omitempty" mapstructure:"client,omitempty"`

	// Kafka svc port for controller connections. It is used if "kraft.enabled: true"
	Controller float64 `json:"controller,omitempty" yaml:"controller,omitempty" mapstructure:"controller,omitempty"`

	// Kafka svc port for external connections
	External float64 `json:"external,omitempty" yaml:"external,omitempty" mapstructure:"external,omitempty"`

	// Kafka svc port for inter-broker connections
	Interbroker float64 `json:"interbroker,omitempty" yaml:"interbroker,omitempty" mapstructure:"interbroker,omitempty"`
}

// Additional settings for the sessionAffinity
type ValuesServiceSessionAffinityConfig map[string]interface{}

type ValuesTls struct {
	// Generate automatically self-signed TLS certificates for Kafka brokers.
	// Currently only supported if `tls.type` is `PEM`
	AutoGenerated bool `json:"autoGenerated,omitempty" yaml:"autoGenerated,omitempty" mapstructure:"autoGenerated,omitempty"`

	// The endpoint identification algorithm to validate server hostname using server
	// certificate
	EndpointIdentificationAlgorithm string `json:"endpointIdentificationAlgorithm,omitempty" yaml:"endpointIdentificationAlgorithm,omitempty" mapstructure:"endpointIdentificationAlgorithm,omitempty"`

	// Name of the existing secret containing the TLS certificates for the Kafka
	// nodes.
	ExistingSecret string `json:"existingSecret,omitempty" yaml:"existingSecret,omitempty" mapstructure:"existingSecret,omitempty"`

	// The secret key from the `tls.existingSecret` containing the keystore
	JksKeystoreKey string `json:"jksKeystoreKey,omitempty" yaml:"jksKeystoreKey,omitempty" mapstructure:"jksKeystoreKey,omitempty"`

	// The secret key from the `tls.existingSecret` or `tls.jksTruststoreSecret`
	// containing the truststore
	JksTruststoreKey string `json:"jksTruststoreKey,omitempty" yaml:"jksTruststoreKey,omitempty" mapstructure:"jksTruststoreKey,omitempty"`

	// Name of the existing secret containing your truststore if truststore not
	// existing or different from the one in the `tls.existingSecret`
	JksTruststoreSecret string `json:"jksTruststoreSecret,omitempty" yaml:"jksTruststoreSecret,omitempty" mapstructure:"jksTruststoreSecret,omitempty"`

	// Password to access the PEM key when it is password-protected.
	KeyPassword string `json:"keyPassword,omitempty" yaml:"keyPassword,omitempty" mapstructure:"keyPassword,omitempty"`

	// Password to access the JKS keystore when it is password-protected. Ignored when
	// 'tls.passwordsSecret' is provided.
	KeystorePassword string `json:"keystorePassword,omitempty" yaml:"keystorePassword,omitempty" mapstructure:"keystorePassword,omitempty"`

	// Name of the secret containing the password to access the JKS files or PEM key
	// when they are password-protected. (`key`: `password`)
	PasswordsSecret string `json:"passwordsSecret,omitempty" yaml:"passwordsSecret,omitempty" mapstructure:"passwordsSecret,omitempty"`

	// The secret key from the tls.passwordsSecret containing the password for the
	// Keystore.
	PasswordsSecretKeystoreKey string `json:"passwordsSecretKeystoreKey,omitempty" yaml:"passwordsSecretKeystoreKey,omitempty" mapstructure:"passwordsSecretKeystoreKey,omitempty"`

	// The secret key from the tls.passwordsSecret containing the password for the PEM
	// key inside 'tls.passwordsSecret'.
	PasswordsSecretPemPasswordKey string `json:"passwordsSecretPemPasswordKey,omitempty" yaml:"passwordsSecretPemPasswordKey,omitempty" mapstructure:"passwordsSecretPemPasswordKey,omitempty"`

	// The secret key from the tls.passwordsSecret containing the password for the
	// Truststore.
	PasswordsSecretTruststoreKey string `json:"passwordsSecretTruststoreKey,omitempty" yaml:"passwordsSecretTruststoreKey,omitempty" mapstructure:"passwordsSecretTruststoreKey,omitempty"`

	// Flag to denote that the Certificate Authority (CA) certificates are bundled
	// with the endpoint cert.
	PemChainIncluded bool `json:"pemChainIncluded,omitempty" yaml:"pemChainIncluded,omitempty" mapstructure:"pemChainIncluded,omitempty"`

	// Sets the default value for the ssl.client.auth Kafka setting.
	SslClientAuth string `json:"sslClientAuth,omitempty" yaml:"sslClientAuth,omitempty" mapstructure:"sslClientAuth,omitempty"`

	// Password to access the JKS truststore when it is password-protected. Ignored
	// when 'tls.passwordsSecret' is provided.
	TruststorePassword string `json:"truststorePassword,omitempty" yaml:"truststorePassword,omitempty" mapstructure:"truststorePassword,omitempty"`

	// Format to use for TLS certificates. Allowed types: `JKS` and `PEM`
	Type string `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`

	// Zookeeper corresponds to the JSON schema field "zookeeper".
	Zookeeper *ValuesTlsZookeeper `json:"zookeeper,omitempty" yaml:"zookeeper,omitempty" mapstructure:"zookeeper,omitempty"`
}

type ValuesTlsZookeeper struct {
	// Enable TLS for Zookeeper client connections.
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Name of the existing secret containing the TLS certificates for ZooKeeper
	// client communications.
	ExistingSecret string `json:"existingSecret,omitempty" yaml:"existingSecret,omitempty" mapstructure:"existingSecret,omitempty"`

	// The secret key from the  tls.zookeeper.existingSecret containing the Keystore.
	ExistingSecretKeystoreKey string `json:"existingSecretKeystoreKey,omitempty" yaml:"existingSecretKeystoreKey,omitempty" mapstructure:"existingSecretKeystoreKey,omitempty"`

	// The secret key from the tls.zookeeper.existingSecret containing the Truststore.
	ExistingSecretTruststoreKey string `json:"existingSecretTruststoreKey,omitempty" yaml:"existingSecretTruststoreKey,omitempty" mapstructure:"existingSecretTruststoreKey,omitempty"`

	// Password to access the JKS keystore when it is password-protected. Ignored when
	// 'tls.passwordsSecret' is provided.
	KeystorePassword string `json:"keystorePassword,omitempty" yaml:"keystorePassword,omitempty" mapstructure:"keystorePassword,omitempty"`

	// Existing secret containing Keystore and Truststore passwords.
	PasswordsSecret string `json:"passwordsSecret,omitempty" yaml:"passwordsSecret,omitempty" mapstructure:"passwordsSecret,omitempty"`

	// The secret key from the tls.zookeeper.passwordsSecret containing the password
	// for the Keystore.
	PasswordsSecretKeystoreKey string `json:"passwordsSecretKeystoreKey,omitempty" yaml:"passwordsSecretKeystoreKey,omitempty" mapstructure:"passwordsSecretKeystoreKey,omitempty"`

	// The secret key from the tls.zookeeper.passwordsSecret containing the password
	// for the Truststore.
	PasswordsSecretTruststoreKey string `json:"passwordsSecretTruststoreKey,omitempty" yaml:"passwordsSecretTruststoreKey,omitempty" mapstructure:"passwordsSecretTruststoreKey,omitempty"`

	// Password to access the JKS truststore when it is password-protected. Ignored
	// when 'tls.passwordsSecret' is provided.
	TruststorePassword string `json:"truststorePassword,omitempty" yaml:"truststorePassword,omitempty" mapstructure:"truststorePassword,omitempty"`

	// Hostname validation.
	VerifyHostname bool `json:"verifyHostname,omitempty" yaml:"verifyHostname,omitempty" mapstructure:"verifyHostname,omitempty"`
}

type ValuesVolumePermissions struct {
	// ContainerSecurityContext corresponds to the JSON schema field
	// "containerSecurityContext".
	ContainerSecurityContext *ValuesVolumePermissionsContainerSecurityContext `json:"containerSecurityContext,omitempty" yaml:"containerSecurityContext,omitempty" mapstructure:"containerSecurityContext,omitempty"`

	// Enable init container that changes the owner and group of the persistent volume
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Image corresponds to the JSON schema field "image".
	Image *ValuesVolumePermissionsImage `json:"image,omitempty" yaml:"image,omitempty" mapstructure:"image,omitempty"`

	// Set container requests and limits for different resources like CPU or memory
	// (essential for production workloads)
	Resources ValuesVolumePermissionsResources `json:"resources,omitempty" yaml:"resources,omitempty" mapstructure:"resources,omitempty"`

	// Set container resources according to one common preset (allowed values: none,
	// nano, small, medium, large, xlarge, 2xlarge). This is ignored if
	// volumePermissions.resources is set (volumePermissions.resources is recommended
	// for production).
	ResourcesPreset string `json:"resourcesPreset,omitempty" yaml:"resourcesPreset,omitempty" mapstructure:"resourcesPreset,omitempty"`
}

type ValuesVolumePermissionsContainerSecurityContext struct {
	// User ID for the init container
	RunAsUser float64 `json:"runAsUser,omitempty" yaml:"runAsUser,omitempty" mapstructure:"runAsUser,omitempty"`
}

type ValuesVolumePermissionsImage struct {
	// Init container volume-permissions image digest in the way sha256:aa.... Please
	// note this parameter, if set, will override the tag
	Digest string `json:"digest,omitempty" yaml:"digest,omitempty" mapstructure:"digest,omitempty"`

	// Init container volume-permissions image pull policy
	PullPolicy string `json:"pullPolicy,omitempty" yaml:"pullPolicy,omitempty" mapstructure:"pullPolicy,omitempty"`

	// Init container volume-permissions image pull secrets
	PullSecrets []interface{} `json:"pullSecrets,omitempty" yaml:"pullSecrets,omitempty" mapstructure:"pullSecrets,omitempty"`

	// Init container volume-permissions image registry
	Registry string `json:"registry,omitempty" yaml:"registry,omitempty" mapstructure:"registry,omitempty"`

	// Init container volume-permissions image repository
	Repository string `json:"repository,omitempty" yaml:"repository,omitempty" mapstructure:"repository,omitempty"`
}

// Set container requests and limits for different resources like CPU or memory
// (essential for production workloads)
type ValuesVolumePermissionsResources map[string]interface{}

type ValuesZookeeper struct {
	// Auth corresponds to the JSON schema field "auth".
	Auth *ValuesZookeeperAuth `json:"auth,omitempty" yaml:"auth,omitempty" mapstructure:"auth,omitempty"`

	// Switch to enable or disable the ZooKeeper helm chart. Must be false if you use
	// KRaft mode.
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Persistence corresponds to the JSON schema field "persistence".
	Persistence *ValuesZookeeperPersistence `json:"persistence,omitempty" yaml:"persistence,omitempty" mapstructure:"persistence,omitempty"`

	// Number of ZooKeeper nodes
	ReplicaCount float64 `json:"replicaCount,omitempty" yaml:"replicaCount,omitempty" mapstructure:"replicaCount,omitempty"`
}

type ValuesZookeeperAuth struct {
	// Client corresponds to the JSON schema field "client".
	Client *ValuesZookeeperAuthClient `json:"client,omitempty" yaml:"client,omitempty" mapstructure:"client,omitempty"`
}

type ValuesZookeeperAuthClient struct {
	// Password that will use ZooKeeper client (zkCli.sh) to authenticate. Must exist
	// in the serverPasswords comma-separated list.
	ClientPassword string `json:"clientPassword,omitempty" yaml:"clientPassword,omitempty" mapstructure:"clientPassword,omitempty"`

	// User that will use ZooKeeper client (zkCli.sh) to authenticate. Must exist in
	// the serverUsers comma-separated list.
	ClientUser string `json:"clientUser,omitempty" yaml:"clientUser,omitempty" mapstructure:"clientUser,omitempty"`

	// Enable ZooKeeper auth
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Comma, semicolon or whitespace separated list of passwords to assign to users
	// when created. Specify them as a string, for example: "pass4user1, pass4user2,
	// pass4admin"
	ServerPasswords string `json:"serverPasswords,omitempty" yaml:"serverPasswords,omitempty" mapstructure:"serverPasswords,omitempty"`

	// Comma, semicolon or whitespace separated list of user to be created. Specify
	// them as a string, for example: "user1,user2,admin"
	ServerUsers string `json:"serverUsers,omitempty" yaml:"serverUsers,omitempty" mapstructure:"serverUsers,omitempty"`
}

type ValuesZookeeperPersistence struct {
	// Persistent Volume access modes
	AccessModes []string `json:"accessModes,omitempty" yaml:"accessModes,omitempty" mapstructure:"accessModes,omitempty"`

	// Enable persistence on ZooKeeper using PVC(s)
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Persistent Volume size
	Size string `json:"size,omitempty" yaml:"size,omitempty" mapstructure:"size,omitempty"`

	// Persistent Volume storage class
	StorageClass string `json:"storageClass,omitempty" yaml:"storageClass,omitempty" mapstructure:"storageClass,omitempty"`
}
